{
  "hash": "1fded115e7a8e57dc1118ecc3c7532ea",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"数据类型和数据结构\"\n---\n\n\n## 数据类型 {style=\"color:red\"}\n\n强制类型转换：字符 \\> 双精度 \\> 整数 \\> 逻辑\n\n### numeric -- 数值型\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(c(1.5, 2), c(3L, 4))\n#> [1] 1.5 2.0 3.0 4.0\n```\n:::\n\n\n#### double -- 双精度\n\n十进制`decimal ()`，科学计数法`scientific ()` ，十六进制`hexadecimal ()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n0.1234\n#> [1] 0.1234\n1.23e4\n#> [1] 12300\n0x111   # 16^2×1+ 16^1×1 + 16^0×1\n#> [1] 273\n\n# 浮点标准定义的特殊值\nInf\n#> [1] Inf\n-Inf\n#> [1] -Inf\nNaN\n#> [1] NaN\n```\n:::\n\n\n#### integer --整型\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(128L)\n#> [1] \"integer\"\n```\n:::\n\n\n### character -- 字符型\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(c(\"c\"))\n#> [1] \"character\"\nclass(\"car\")\n#> [1] \"character\"\n```\n:::\n\n\n### logical -- 逻辑型\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(c(T,FALSE))\n#> [1] \"logical\"\nclass(c(TRUE,FALSE))\n#> [1] \"logical\"\n```\n:::\n\n\n### complex型\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\ntypeof(c(1+2i,3-4i)) \n#> [1] \"complex\"\nclass(c(1+2i,3-4i))\n#> [1] \"complex\"\n```\n:::\n\n\n### raw型\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncharToRaw(\"abcde12345\") #字符串中每个字符的原始存储格式（十六进制？）\n#>  [1] 61 62 63 64 65 31 32 33 34 35\ntypeof(charToRaw(\"abcde12345\")) \n#> [1] \"raw\"\nclass(charToRaw(\"abcde12345\"))\n#> [1] \"raw\"\n```\n:::\n\n\n### NA -- 缺失值\n\n从技术上讲，每种原子类型有一个缺失值：NA_logical、NA_integer、NA_double、NA_character。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNA\n#> [1] NA\n```\n:::\n\n\n## 数据结构 {style=\"color:red\"}\n\n**class**：是一种基于***面向对象编程***的R的抽象类型划分，或者理解为一种数据结构。\n\n### atomic vectors\n\n向量,同一类元素的集合。 `c()  Combine Values into a Vector or List`\n\n![](images/summary-tree-atomic.png){fig-align=\"center\" width=\"50%\"}\n\n还有不常用的complex 和 raw。\n\n| 每一种原子向量都有一种特殊的语法来创建单元素向量，也就是标量**scalar**。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#单元素向量\n1 == c(1)\n#> [1] TRUE\nis.vector(1)\n#> [1] TRUE\n  \n\"a\"\n#> [1] \"a\"\nis.vector(\"a\")\n#> [1] TRUE\n\n#使用函数c()创建向量\n\nc(1)\n#> [1] 1\nc(1,2,3,4,5)\n#> [1] 1 2 3 4 5\nc(\"a\",\"b\",\"c\")\n#> [1] \"a\" \"b\" \"c\"\nc(list(1),list(T)) |> is.vector()\n#> [1] TRUE\n```\n:::\n\n\n列表不存储值本身，而是存储对它们的引用：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl1 <- list(1,2,3)\n```\n:::\n\n\n![](images/list.png){#fig-list fig-align=\"center\" width=\"50%\"}\n\n#### 属性\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 1:3\nattr(a, \"x\") <- \"abcdef\"\nattr(a, \"x\")\n#> [1] \"abcdef\"\nattr(a, \"y\") <- 4:6\nstr(attributes(a))\n#> List of 2\n#>  $ x: chr \"abcdef\"\n#>  $ y: int [1:3] 4 5 6\n\n# 或者\na <- structure(\n  1:3, \n  x = \"abcdef\",\n  y = 4:6\n)\nstr(attributes(a))\n#> List of 2\n#>  $ x: chr \"abcdef\"\n#>  $ y: int [1:3] 4 5 6\n```\n:::\n\n\n大多数操作都会丢失大多数属性。\n\n只有两个属性是例行保留的：\n\n1.  names，一个字符向量，为每个元素命名。\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    # When creating it: \n    x <- c(a = 1, b = 2, c = 3)\n    attributes(x)\n    #> $names\n    #> [1] \"a\" \"b\" \"c\"\n    names(x)\n    #> [1] \"a\" \"b\" \"c\"\n    \n    # By assigning a character vector to names()\n    x <- 1:3\n    names(x) <- c(\"a\", \"b\", \"c\")\n    \n    # Inline, with setNames():\n    x <- setNames(1:3, c(\"a\", \"b\", \"c\"))\n    ```\n    :::\n\n\n2.  dim，dimensions 的缩写，整数向量，用于将向量转换为矩阵或数组。\n\n    对于原子向量，dimension 属性通常用于创建矩阵或数组。对于列表，dimension 属性可用于创建列表矩阵或列表数组：\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    z <- 1:6\n    dim(z) <- c(3, 2, 1)\n    z\n    #> , , 1\n    #> \n    #>      [,1] [,2]\n    #> [1,]    1    4\n    #> [2,]    2    5\n    #> [3,]    3    6\n    attributes(z)\n    #> $dim\n    #> [1] 3 2 1\n    dim(z)\n    #> [1] 3 2 1\n    \n    l <- list(1:3, \"a\", TRUE, 1.0)\n    dim(l) <- c(2, 2)\n    l\n    #>      [,1]      [,2]\n    #> [1,] integer,3 TRUE\n    #> [2,] \"a\"       1\n    l[[1,2]]\n    #> [1] TRUE\n    ```\n    :::\n\n\n    | 向量            | 矩阵                  | 数组           |\n    |-----------------|-----------------------|----------------|\n    | names()         | rownames(),colnames() | dimnames()     |\n    | length()        | nrow(),ncol()         | dim()          |\n    | c()             | rbind(),cbind()       | abind::abind() |\n    | ---             | t()                   | aperm()        |\n    | is.null(dim(x)) | is.matrix()           | is.array()     |\n\n要保留其他属性，需要创建S3 类。\n\n### S3原子向量\n\nbase R 中使用的四个重要的 S3 向量：\n\n1.  分类数据，其中值来自**factor**向量中记录的一组固定水平。\n\n2.  日期（具有日期分辨率），记录在**Date**向量中。\n\n3.  日期时间（具有秒或亚秒分辨率），存储在 **POSIXct** 向量中。\n\n4.  持续时间，存储在**difftime**向量中。\n\n![](images/summary-tree-s3-baseR.png){fig-align=\"center\" width=\"50%\"}\n\n#### factor\n\n因子，分类变量，建立在具有两个属性（class，levels）的 **integer 向量**之上。\n\n`factor(vector,ordered=FALSE,levels=c(v1,v2,…),labels= ,...)` ，在内存中以整数向量`c(1,2,3,...,k)`存储。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 存储形式\nx <- factor(c(\"a\", \"b\", \"b\", \"a\"))\nx\n#> [1] a b b a\n#> Levels: a b\ntypeof(x)\n#> [1] \"integer\"\nattributes(x)\n#> $levels\n#> [1] \"a\" \"b\"\n#> \n#> $class\n#> [1] \"factor\"\nlevels(x)\n#> [1] \"a\" \"b\"\nclass(x)\n#> [1] \"factor\"\n\n\n# 名义变量 nominal variable\ndiabetes<-c(\"t1\",\"t2\",\"t1\",\"t1\") \nattributes(diabetes)\n#> NULL\ndiabetes<-factor(diabetes)\nattributes(diabetes)\n#> $levels\n#> [1] \"t1\" \"t2\"\n#> \n#> $class\n#> [1] \"factor\"\n\n\n# 顺序变量 ordinal variable     默认水平根据字母顺序而定\nstatus<-c(\"poor\",\"better\",\"best\",\"poor\")\nstatus<-factor(status,ordered = TRUE) \nstr(status) \n#>  Ord.factor w/ 3 levels \"best\"<\"better\"<..: 3 2 1 3\nstatus<-factor(status,ordered =TRUE,levels = c(\"poor\",\"better\",\"best\")) \nstr(status) \n#>  Ord.factor w/ 3 levels \"poor\"<\"better\"<..: 1 2 3 1\n\n\n#改变外在标签\nsex<-c(1,2,2,1)\nsex\n#> [1] 1 2 2 1\nsex<-factor(sex,levels=c(1,2),labels = c(\"男\",\"女\")) \nstr(sex) \n#>  Factor w/ 2 levels \"男\",\"女\": 1 2 2 1\nsex\n#> [1] 男 女 女 男\n#> Levels: 男 女\n\nleadership <- read_csv(\"data/leadership.txt\") |> column_to_rownames(var = \"id\")\n# 连续型变量→因子\nleadership$agecat<-cut(leadership$age,\n                    breaks = c(0,18,45,65,Inf),\n                    labels=c(\"minor\",\"young\",\"middle_age\",\"elder\"),\n                    include.lowest = TRUE,\n                    right = TRUE\n                    )\nleadership$agecat\n#> [1] young young young elder elder\n#> Levels: minor young middle_age elder\n```\n:::\n\n\n#### Date\n\n日期向量建立在 **double 向量**之上，具有`class \"Date\"`属性。\n\n日期 默认格式：`\"%Y-%m-%d\" xxxx-xx-xx,例如：2023-03-15`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntoday <- Sys.Date()\ntoday\n#> [1] \"2024-04-20\"\ntypeof(today)\n#> [1] \"double\"\nattributes(today)\n#> $class\n#> [1] \"Date\"\nclass(today)\n#> [1] \"Date\"\n\nas.Date(c(\"02 14-2002\",\"01 04-2013\"),\"%m %d-%Y\") #以\"%m %d-%Y\"格式读入\n#> [1] \"2002-02-14\" \"2013-01-04\"\nformat(Sys.Date(),\"%Y/%m/%d\") #以\"%Y/%m/%d\"格式输出\n#> [1] \"2024/04/20\"\n\n\n# 双精度值（通过剥离类来查看）表示自 1970 年 1 月 1 日以来的天数\ndate <- as.Date(\"1970-02-01\")\nunclass(date)\n#> [1] 31\n```\n:::\n\n\n#### Datetime\n\nPOSIXct 和 POSIXlt\n\n\"POSIX\"是可移植操作系统接口（ Portable Operating System Interface）的缩写，这是一个跨平台标准系列。\"ct\"代表calendar time（C 中的类型），\"lt\"代表local time（C 中的类型）。\n\nPOSIXct 向量建立在 **double 向量**之上，其中值表示自 1970-01-01 以来的秒数\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnow_ct <- as.POSIXct(\"2024-04-20 15:45\", tz = \"Asia/Shanghai\")\nnow_ct\n#> [1] \"2024-04-20 15:45:00 CST\"\ntypeof(now_ct)\n#> [1] \"double\"\nattributes(now_ct)\n#> $class\n#> [1] \"POSIXct\" \"POSIXt\" \n#> \n#> $tzone\n#> [1] \"Asia/Shanghai\"\nclass(now_ct)\n#> [1] \"POSIXct\" \"POSIXt\"\n```\n:::\n\n\n#### Durations\n\n持续时间（表示日期对或日期时间对之间的时间量）存储在difftimes中。Difftimes 建立在 **double** 之上，并且具有确定整数应如何解释的属性。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunits_1 <- as.difftime(1, units = \"weeks\")  #units = c(\"auto\", \"secs\", \"mins\", \"hours\",\"days\", \"weeks\"))\n\nunits_1\n#> Time difference of 1 weeks\ntypeof(units_1)\n#> [1] \"double\"\nattributes(units_1)\n#> $class\n#> [1] \"difftime\"\n#> \n#> $units\n#> [1] \"weeks\"\nclass(units_1)\n#> [1] \"difftime\"\nunits(units_1)\n#> [1] \"weeks\"\nunits(units_1) <- \"days\"\n\nattributes(units_1)\n#> $units\n#> [1] \"days\"\n#> \n#> $class\n#> [1] \"difftime\"\n```\n:::\n\n\n### matrix\n\n矩阵，所有元素必须是同一类型。\n\n`matrix(data= ,nrow=1  ,ncol=1  ,byrow=FALSE ,dimnames=list(rnames,cnames) ,...)`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnum<-c(16,22,24,28)\nrnames<-c(\"R1\",\"R2\")\ncnames<-c(\"C1\",\"C2\")\nm<-matrix(num,nrow=2,ncol=2,byrow=TRUE,dimnames=list(rnames,cnames))\nm\n#>    C1 C2\n#> R1 16 22\n#> R2 24 28\n\nattributes(m)\n#> $dim\n#> [1] 2 2\n#> \n#> $dimnames\n#> $dimnames[[1]]\n#> [1] \"R1\" \"R2\"\n#> \n#> $dimnames[[2]]\n#> [1] \"C1\" \"C2\"\ndim(m)\n#> [1] 2 2\nrownames(m)\n#> [1] \"R1\" \"R2\"\ncolnames(m)\n#> [1] \"C1\" \"C2\"\n```\n:::\n\n\n### array\n\n数组，所有元素必须是同一类型。\n\n`array(data,dim_numeric_vector=c(...),dimnames = list(dim1,dim2,...),...)`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv<-1:24 \ndim1<-c(\"A1\",\"A2\",\"A3\") \ndim2<-c(\"B1\",\"B2\",\"B3\",\"B4\")\ndim3<-c(\"C1\",\"C2\") \narray_3d<-array(v,c(3,4,2),dimnames = list(dim1,dim2,dim3)) \narray_3d\n#> , , C1\n#> \n#>    B1 B2 B3 B4\n#> A1  1  4  7 10\n#> A2  2  5  8 11\n#> A3  3  6  9 12\n#> \n#> , , C2\n#> \n#>    B1 B2 B3 B4\n#> A1 13 16 19 22\n#> A2 14 17 20 23\n#> A3 15 18 21 24\nattributes(array_3d)\n#> $dim\n#> [1] 3 4 2\n#> \n#> $dimnames\n#> $dimnames[[1]]\n#> [1] \"A1\" \"A2\" \"A3\"\n#> \n#> $dimnames[[2]]\n#> [1] \"B1\" \"B2\" \"B3\" \"B4\"\n#> \n#> $dimnames[[3]]\n#> [1] \"C1\" \"C2\"\ndimnames(array_3d)\n#> [[1]]\n#> [1] \"A1\" \"A2\" \"A3\"\n#> \n#> [[2]]\n#> [1] \"B1\" \"B2\" \"B3\" \"B4\"\n#> \n#> [[3]]\n#> [1] \"C1\" \"C2\"\n```\n:::\n\n\n### list\n\n从技术上讲，列表的每个元素实际上是相同的类型，因为每个元素实际上是对另一个对象的引用 @fig-list ，该对象可以是任何类型。\n\n列表，`list(name1=object1,name2=object2,...)`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmylist<-list(title=\"My list\",\n             matr=matrix(c(\"a1\",\"b1\",\"a2\",\"b2\"),nrow=2,ncol=2,byrow=TRUE,\n                           dimnames = list(c(\"X1\",\"X2\"),c(\"Y1\",\"Y2\"))\n                         ),\n             df=data.frame(id=matrix(c(\"Lisa\",\"BOb\",\"John\",\"Jule\"),\n                                     nrow=4,ncol=1,byrow=TRUE\n                                     ),\n                           int=c(3,5,7,9),\n                           TF=c(T,T,T,F)\n                           ),\n             list=list(a=c(1,2,3),b=c(\"A\",\"B\"))\n             )\nmylist\n#> $title\n#> [1] \"My list\"\n#> \n#> $matr\n#>    Y1   Y2  \n#> X1 \"a1\" \"b1\"\n#> X2 \"a2\" \"b2\"\n#> \n#> $df\n#>     id int    TF\n#> 1 Lisa   3  TRUE\n#> 2  BOb   5  TRUE\n#> 3 John   7  TRUE\n#> 4 Jule   9 FALSE\n#> \n#> $list\n#> $list$a\n#> [1] 1 2 3\n#> \n#> $list$b\n#> [1] \"A\" \"B\"\ntypeof(mylist)\n#> [1] \"list\"\nattributes(mylist)\n#> $names\n#> [1] \"title\" \"matr\"  \"df\"    \"list\"\nclass(mylist)\n#> [1] \"list\"\nnames(mylist)\n#> [1] \"title\" \"matr\"  \"df\"    \"list\"\n```\n:::\n\n\n### data frame/tibble\n\n建立在`\"list\"`之上的两个最重要的 S3 向量是数据框和 tibble\n\n![](images/summary-tree-s3-df_tbl.png){fig-align=\"center\" width=\"30%\"}\n\n数据框是列向量具有 names，row.names ，class\"data.frame\" 属性的命名列表。\n\n与常规列表相比，数据框每个向量的长度必须相同。这为数据框提供了矩形结构，并解释了为什么它们共享矩阵和列表的属性\n\n\n::: {.cell}\n\n```{.r .cell-code}\nid<-c(001231,001241,001413,001244) \nage<-c(21,14,52,15) \ndiabetes<-c(\"t1\",\"t2\",\"t1\",\"t1\") \nstatus<-c(\"poor\",\"better\",\"best\",\"poor\") \ndf1<-data.frame(patientID=id,age,diabetes,status,row.names = c(1,2,3,4),\n                stringsAsFactors = FALSE) # 4个列向量组成数据框 \ndf1\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| patientID| age|diabetes |status |\n|---------:|---:|:--------|:------|\n|      1231|  21|t1       |poor   |\n|      1241|  14|t2       |better |\n|      1413|  52|t1       |best   |\n|      1244|  15|t1       |poor   |\n\n</div>\n:::\n\n```{.r .cell-code}\ntypeof(df1)\n#> [1] \"list\"\nattributes(df1)\n#> $names\n#> [1] \"patientID\" \"age\"       \"diabetes\"  \"status\"   \n#> \n#> $class\n#> [1] \"data.frame\"\n#> \n#> $row.names\n#> [1] \"1\" \"2\" \"3\" \"4\"\nclass(df1)\n#> [1] \"data.frame\"\nnames(df1)\n#> [1] \"patientID\" \"age\"       \"diabetes\"  \"status\"\ncolnames(df1)\n#> [1] \"patientID\" \"age\"       \"diabetes\"  \"status\"\nrow.names(df1)\n#> [1] \"1\" \"2\" \"3\" \"4\"\nrownames(df1)\n#> [1] \"1\" \"2\" \"3\" \"4\"\n```\n:::\n\n\n`tibblle`与`data frame`共享相同的结构。区别是`class`属性更多,不会自动进行强制类型转换，不会自动转换非法名称（自动反引号非法名称）， tibbles 只能循环较短的长度为 1 的向量，允许引用在构造过程中创建的变量。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tibble)\ndf2 <- tibble(x = 1:3, y = letters[1:3])\ntypeof(df2)\n#> [1] \"list\"\nattributes(df2)\n#> $class\n#> [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n#> \n#> $row.names\n#> [1] 1 2 3\n#> \n#> $names\n#> [1] \"x\" \"y\"\n\n\nnames(tibble(`1` = 1))\n#> [1] \"1\"\n\ntibble(x = 1:4, y = 1)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|  x|  y|\n|--:|--:|\n|  1|  1|\n|  2|  1|\n|  3|  1|\n|  4|  1|\n\n</div>\n:::\n\n```{.r .cell-code}\n#tibble(x = 1:4, y = 1:2)\n#> Error in `tibble()`:\n#> ! Tibble columns must have compatible sizes.\n#> • Size 4: Existing data.\n#> • Size 2: Column `y`.\n#> ℹ Only values of size one are recycled.\ntibble(\n  x = 1:3,\n  y = x * 2\n)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|  x|  y|\n|--:|--:|\n|  1|  2|\n|  2|  4|\n|  3|  6|\n\n</div>\n:::\n:::\n\n\n#### 行名→列\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf3 <- data.frame(\n  age = c(35, 27, 18),\n  hair = c(\"blond\", \"brown\", \"black\"),\n  row.names = c(\"Bob\", \"Susan\", \"Sam\")\n)\ndf3 |> rownames_to_column(var = \"name\")\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|name  | age|hair  |\n|:-----|---:|:-----|\n|Bob   |  35|blond |\n|Susan |  27|brown |\n|Sam   |  18|black |\n\n</div>\n:::\n\n```{.r .cell-code}\nas_tibble(df3, rownames = \"name\")\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|name  | age|hair  |\n|:-----|---:|:-----|\n|Bob   |  35|blond |\n|Susan |  27|brown |\n|Sam   |  18|black |\n\n</div>\n:::\n\n```{.r .cell-code}\n\n\nis_tibble(df2)\n#> [1] TRUE\nis_tibble(df3)\n#> [1] FALSE\nas_tibble(df3)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| age|hair  |\n|---:|:-----|\n|  35|blond |\n|  27|brown |\n|  18|black |\n\n</div>\n:::\n:::\n\n\n#### 列表列\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(x = 1:3)\ndf$y <- list(1:2, 1:3, 1:4)\n\ndata.frame(\n  x = 1:3, \n  y = I(list(1:2, 1:3, 1:4))\n)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|  x|y          |\n|--:|:----------|\n|  1|1, 2       |\n|  2|1, 2, 3    |\n|  3|1, 2, 3, 4 |\n\n</div>\n:::\n\n```{.r .cell-code}\n\ntibble(\n  x = 1:3, \n  y = list(1:2, 1:3, 1:4)\n)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|  x|y          |\n|--:|:----------|\n|  1|1, 2       |\n|  2|1, 2, 3    |\n|  3|1, 2, 3, 4 |\n\n</div>\n:::\n:::\n\n\n### 矩阵和数据框列\n\n行数必须相等\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndfm <- data.frame(\n  x = 1:3 * 10\n)\ndfm$y <- matrix(1:9, nrow = 3)\ndfm$z <- data.frame(a = 3:1, b = letters[1:3], stringsAsFactors = FALSE)\ndfm[1, ]\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|  x|  y|z  |\n|--:|--:|:--|\n| 10|  1|3  |\n\n</div>\n:::\n:::\n\n\n## `NULL`\n\n长度始终为零，并且没有属性。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(NULL)\n#> [1] \"NULL\"\nlength(NULL)\n#> [1] 0\nis.null(NULL)\n#> [1] TRUE\nc()\n#> NULL\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}