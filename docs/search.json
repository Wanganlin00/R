[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R data science",
    "section": "",
    "text": "参考资料",
    "crumbs": [
      "参考资料"
    ]
  },
  {
    "objectID": "index.html#参考资料",
    "href": "index.html#参考资料",
    "title": "R data science",
    "section": "",
    "text": "R for data science\nAdvanced R\nggplot2: Elegant Graphics for Data Analysis (3e)\nhttps://exts.ggplot2.tidyverse.org/gallery/\nhttps://www.datanovia.com/en/blog/tag/ggpubr/\ntidyverse.org\nbookdown.org\nR in action 3rd\nEfficient R\ndata.table\nR Packages(2e)\narrow.apache.org\nPandoc",
    "crumbs": [
      "参考资料"
    ]
  },
  {
    "objectID": "basic_data_type_class.html",
    "href": "basic_data_type_class.html",
    "title": "\n1  数据类型和数据结构\n",
    "section": "",
    "text": "1.1 数据类型\n强制类型转换：字符 &gt; 双精度 &gt; 整数 &gt; 逻辑",
    "crumbs": [
      "Programming",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>数据类型和数据结构</span>"
    ]
  },
  {
    "objectID": "basic_data_type_class.html#数据类型",
    "href": "basic_data_type_class.html#数据类型",
    "title": "\n1  数据类型和数据结构\n",
    "section": "",
    "text": "1.1.1 numeric – 数值型\n\nCodec(c(1.5, 2), c(3L, 4))\n#&gt; [1] 1.5 2.0 3.0 4.0\n\n\n\n1.1.1.1 double – 双精度\n十进制decimal ()，科学计数法scientific () ，十六进制hexadecimal ()\n\nCode0.1234\n#&gt; [1] 0.1234\n1.23e4\n#&gt; [1] 12300\n0x111   # 16^2×1+ 16^1×1 + 16^0×1\n#&gt; [1] 273\n\n\n浮点标准定义的特殊值\n\n无穷大\nNot a Number\n\n\nCodeInf\n#&gt; [1] Inf\n-Inf\n#&gt; [1] -Inf\nNaN\n#&gt; [1] NaN\n0/0\n#&gt; [1] NaN\nis.nan(0/0)\n#&gt; [1] TRUE\n\n\n\n1.1.1.2 integer –整型\n\nCodeclass(128L)\n#&gt; [1] \"integer\"\n\n\n\n1.1.2 character – 字符型\n\nCodetypeof(c(\"c\"))\n#&gt; [1] \"character\"\nclass(\"car\")\n#&gt; [1] \"character\"\n\n\n\n1.1.3 logical – 逻辑型\n\nCodetypeof(c(T,FALSE))\n#&gt; [1] \"logical\"\nclass(c(TRUE,FALSE))\n#&gt; [1] \"logical\"\n\n\n\n1.1.4 complex型\n\nCode\ntypeof(c(1+2i,3-4i)) \n#&gt; [1] \"complex\"\nclass(c(1+2i,3-4i))\n#&gt; [1] \"complex\"\n\n\n\n1.1.5 raw型\n\nCodecharToRaw(\"abcde12345\") #字符串中每个字符的原始存储格式（十六进制？）\n#&gt;  [1] 61 62 63 64 65 31 32 33 34 35\ntypeof(charToRaw(\"abcde12345\")) \n#&gt; [1] \"raw\"\nclass(charToRaw(\"abcde12345\"))\n#&gt; [1] \"raw\"\n\n\n\n1.1.6 NA – 缺失值\n从技术上讲，每种原子类型有一个缺失值：NA_logical、NA_integer、NA_double、NA_character。\nNot Available\n\nCodeNA\n#&gt; [1] NA\nis.na(NA)\n#&gt; [1] TRUE\nanyNA(c(1,3,NA,9))\n#&gt; [1] TRUE\nx&lt;-c(2,3,1,4,5,NA,NA)\nna.omit(x)\n#&gt; [1] 2 3 1 4 5\n#&gt; attr(,\"na.action\")\n#&gt; [1] 6 7\n#&gt; attr(,\"class\")\n#&gt; [1] \"omit\"",
    "crumbs": [
      "Programming",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>数据类型和数据结构</span>"
    ]
  },
  {
    "objectID": "basic_data_type_class.html#数据结构",
    "href": "basic_data_type_class.html#数据结构",
    "title": "\n1  数据类型和数据结构\n",
    "section": "\n1.2 数据结构",
    "text": "1.2 数据结构\nclass：是一种基于面向对象编程的R的抽象类型划分，或者理解为一种数据结构。\n\n1.2.1 atomic vectors\n向量,同一类元素的集合。 c()  Combine Values into a Vector or List\n\n\n\n\n还有不常用的complex 和 raw。\n每一种原子向量都有一种特殊的语法来创建单元素向量，也就是标量scalar。\n\nCode#单元素向量\n1 == c(1)\n#&gt; [1] TRUE\nis.vector(1)\n#&gt; [1] TRUE\n  \n\"a\"\n#&gt; [1] \"a\"\nis.vector(\"a\")\n#&gt; [1] TRUE\n\n#使用函数c()创建向量\n\nc(1)\n#&gt; [1] 1\nc(1,2,3,4,5)\n#&gt; [1] 1 2 3 4 5\nc(\"a\",\"b\",\"c\")\n#&gt; [1] \"a\" \"b\" \"c\"\nc(list(1),list(T)) |&gt; is.vector()\n#&gt; [1] TRUE\n\n\n列表不存储值本身，而是存储对它们的引用：\n\nCodel1 &lt;- list(1,2,3)\n\n\n\n\n\n\n\nFigure 1.1\n\n\n\n1.2.1.1 属性\n\nCodea &lt;- 1:3\nattr(a, \"x\") &lt;- \"abcdef\"\nattr(a, \"x\")\n#&gt; [1] \"abcdef\"\nattr(a, \"y\") &lt;- 4:6\nstr(attributes(a))\n#&gt; List of 2\n#&gt;  $ x: chr \"abcdef\"\n#&gt;  $ y: int [1:3] 4 5 6\n\n# 或者\na &lt;- structure(\n  1:3, \n  x = \"abcdef\",\n  y = 4:6\n)\nstr(attributes(a))\n#&gt; List of 2\n#&gt;  $ x: chr \"abcdef\"\n#&gt;  $ y: int [1:3] 4 5 6\n\n\n大多数操作都会丢失大多数属性。\n只有两个属性是例行保留的：\n\n\nnames，一个字符向量，为每个元素命名。\n\nCode# When creating it: \nx &lt;- c(a = 1, b = 2, c = 3)\nattributes(x)\n#&gt; $names\n#&gt; [1] \"a\" \"b\" \"c\"\nnames(x)\n#&gt; [1] \"a\" \"b\" \"c\"\n\n# By assigning a character vector to names()\nx &lt;- 1:3\nnames(x) &lt;- c(\"a\", \"b\", \"c\")\n\n# Inline, with setNames():\nx &lt;- setNames(1:3, c(\"a\", \"b\", \"c\"))\n\n\n\n\ndim，dimensions 的缩写，整数向量，用于将向量转换为矩阵或数组。\n对于原子向量，dimension 属性通常用于创建矩阵或数组。对于列表，dimension 属性可用于创建列表矩阵或列表数组：\n\nCodez &lt;- 1:6\ndim(z) &lt;- c(3, 2, 1)\nz\n#&gt; , , 1\n#&gt; \n#&gt;      [,1] [,2]\n#&gt; [1,]    1    4\n#&gt; [2,]    2    5\n#&gt; [3,]    3    6\nattributes(z)\n#&gt; $dim\n#&gt; [1] 3 2 1\ndim(z)\n#&gt; [1] 3 2 1\n\nl &lt;- list(1:3, \"a\", TRUE, 1.0)\ndim(l) &lt;- c(2, 2)\nl\n#&gt;      [,1]      [,2]\n#&gt; [1,] integer,3 TRUE\n#&gt; [2,] \"a\"       1\nl[[1,2]]\n#&gt; [1] TRUE\n\n\n\n\n向量\n矩阵\n数组\n\n\n\nnames()\nrownames(),colnames()\ndimnames()\n\n\nlength()\nnrow(),ncol()\ndim()\n\n\nc()\nrbind(),cbind()\nabind::abind()\n\n\n—\nt()\naperm()\n\n\nis.null(dim(x))\nis.matrix()\nis.array()\n\n\n\n\n\n要保留其他属性，需要创建S3 类。\n\n1.2.2 S3原子向量\nbase R 中使用的四个重要的 S3 向量：\n\n分类数据，其中值来自factor向量中记录的一组固定水平。\n日期（具有日期分辨率），记录在Date向量中。\n日期时间（具有秒或亚秒分辨率），存储在 POSIXct 向量中。\n持续时间，存储在difftime向量中。\n\n\n\n\n\n\n1.2.2.1 factor\n因子，分类变量，建立在具有两个属性（class，levels）的 integer 向量之上。\nfactor(vector,ordered=FALSE,levels=c(v1,v2,…),labels= ,...) ，在内存中以整数向量c(1,2,3,...,k)存储。\n\nCode# 存储形式\nx &lt;- factor(c(\"a\", \"b\", \"b\", \"a\"))\nx\n#&gt; [1] a b b a\n#&gt; Levels: a b\ntypeof(x)\n#&gt; [1] \"integer\"\nattributes(x)\n#&gt; $levels\n#&gt; [1] \"a\" \"b\"\n#&gt; \n#&gt; $class\n#&gt; [1] \"factor\"\nlevels(x)\n#&gt; [1] \"a\" \"b\"\nclass(x)\n#&gt; [1] \"factor\"\n\n\n# 名义变量 nominal variable\ndiabetes&lt;-c(\"t1\",\"t2\",\"t1\",\"t1\") \nattributes(diabetes)\n#&gt; NULL\ndiabetes&lt;-factor(diabetes)\nattributes(diabetes)\n#&gt; $levels\n#&gt; [1] \"t1\" \"t2\"\n#&gt; \n#&gt; $class\n#&gt; [1] \"factor\"\n\n\n# 顺序变量 ordinal variable     默认水平根据字母顺序而定\nstatus&lt;-c(\"poor\",\"better\",\"best\",\"poor\")\nstatus&lt;-factor(status,ordered = TRUE) \nstr(status) \n#&gt;  Ord.factor w/ 3 levels \"best\"&lt;\"better\"&lt;..: 3 2 1 3\nstatus&lt;-factor(status,ordered =TRUE,levels = c(\"poor\",\"better\",\"best\")) \nstr(status) \n#&gt;  Ord.factor w/ 3 levels \"poor\"&lt;\"better\"&lt;..: 1 2 3 1\n\n\n#改变外在标签\nsex&lt;-c(1,2,2,1)\nsex\n#&gt; [1] 1 2 2 1\nsex&lt;-factor(sex,levels=c(1,2),labels = c(\"男\",\"女\")) \nstr(sex) \n#&gt;  Factor w/ 2 levels \"男\",\"女\": 1 2 2 1\nsex\n#&gt; [1] 男 女 女 男\n#&gt; Levels: 男 女\n\nleadership &lt;- read_csv(\"data/leadership.txt\") |&gt; column_to_rownames(var = \"id\")\n# 连续型变量→因子\nleadership$agecat&lt;-cut(leadership$age,\n                    breaks = c(0,18,45,65,Inf),\n                    labels=c(\"minor\",\"young\",\"middle_age\",\"elder\"),\n                    include.lowest = TRUE,\n                    right = TRUE\n                    )\nleadership$agecat\n#&gt; [1] young young young elder elder\n#&gt; Levels: minor young middle_age elder\n\n\n\n1.2.2.2 Date\n日期向量建立在 double 向量之上，具有class \"Date\"属性。\n日期 默认格式：\"%Y-%m-%d\" xxxx-xx-xx,例如：2023-03-15\n\nCodetoday &lt;- Sys.Date()\ntoday\n#&gt; [1] \"2024-04-21\"\ntypeof(today)\n#&gt; [1] \"double\"\nattributes(today)\n#&gt; $class\n#&gt; [1] \"Date\"\nclass(today)\n#&gt; [1] \"Date\"\n\nas.Date(c(\"02 14-2002\",\"01 04-2013\"),\"%m %d-%Y\") #以\"%m %d-%Y\"格式读入\n#&gt; [1] \"2002-02-14\" \"2013-01-04\"\nformat(Sys.Date(),\"%Y/%m/%d\") #以\"%Y/%m/%d\"格式输出\n#&gt; [1] \"2024/04/21\"\n\n\n# 双精度值（通过剥离类来查看）表示自 1970 年 1 月 1 日以来的天数\ndate &lt;- as.Date(\"1970-02-01\")\nunclass(date)\n#&gt; [1] 31\n\n\n\n1.2.2.3 Datetime\nPOSIXct 和 POSIXlt\n“POSIX”是可移植操作系统接口（ Portable Operating System Interface）的缩写，这是一个跨平台标准系列。“ct”代表calendar time（C 中的类型），“lt”代表local time（C 中的类型）。\nPOSIXct 向量建立在 double 向量之上，其中值表示自 1970-01-01 以来的秒数\n\nCodenow_ct &lt;- as.POSIXct(\"2024-04-20 15:45\", tz = \"Asia/Shanghai\")\nnow_ct\n#&gt; [1] \"2024-04-20 15:45:00 CST\"\ntypeof(now_ct)\n#&gt; [1] \"double\"\nattributes(now_ct)\n#&gt; $class\n#&gt; [1] \"POSIXct\" \"POSIXt\" \n#&gt; \n#&gt; $tzone\n#&gt; [1] \"Asia/Shanghai\"\nclass(now_ct)\n#&gt; [1] \"POSIXct\" \"POSIXt\"\n\n\n\n1.2.2.4 Durations\n持续时间（表示日期对或日期时间对之间的时间量）存储在difftimes中。Difftimes 建立在 double 之上，并且具有确定整数应如何解释的属性。\n\nCodeunits_1 &lt;- as.difftime(1, units = \"weeks\")  #units = c(\"auto\", \"secs\", \"mins\", \"hours\",\"days\", \"weeks\"))\n\nunits_1\n#&gt; Time difference of 1 weeks\ntypeof(units_1)\n#&gt; [1] \"double\"\nattributes(units_1)\n#&gt; $class\n#&gt; [1] \"difftime\"\n#&gt; \n#&gt; $units\n#&gt; [1] \"weeks\"\nclass(units_1)\n#&gt; [1] \"difftime\"\nunits(units_1)\n#&gt; [1] \"weeks\"\nunits(units_1) &lt;- \"days\"\n\nattributes(units_1)\n#&gt; $units\n#&gt; [1] \"days\"\n#&gt; \n#&gt; $class\n#&gt; [1] \"difftime\"\n\n\n\n1.2.3 matrix\n矩阵，所有元素必须是同一类型。\nmatrix(data= ,nrow=1  ,ncol=1  ,byrow=FALSE ,dimnames=list(rnames,cnames) ,...)\n\nCodenum&lt;-c(16,22,24,28)\nrnames&lt;-c(\"R1\",\"R2\")\ncnames&lt;-c(\"C1\",\"C2\")\nm&lt;-matrix(num,nrow=2,ncol=2,byrow=TRUE,dimnames=list(rnames,cnames))\nm\n#&gt;    C1 C2\n#&gt; R1 16 22\n#&gt; R2 24 28\n\nattributes(m)\n#&gt; $dim\n#&gt; [1] 2 2\n#&gt; \n#&gt; $dimnames\n#&gt; $dimnames[[1]]\n#&gt; [1] \"R1\" \"R2\"\n#&gt; \n#&gt; $dimnames[[2]]\n#&gt; [1] \"C1\" \"C2\"\ndim(m)\n#&gt; [1] 2 2\nrownames(m)\n#&gt; [1] \"R1\" \"R2\"\ncolnames(m)\n#&gt; [1] \"C1\" \"C2\"\n\n\n\n1.2.4 array\n数组，所有元素必须是同一类型。\narray(data,dim_numeric_vector=c(...),dimnames = list(dim1,dim2,...),...)\n\nCodev&lt;-1:24 \ndim1&lt;-c(\"A1\",\"A2\",\"A3\") \ndim2&lt;-c(\"B1\",\"B2\",\"B3\",\"B4\")\ndim3&lt;-c(\"C1\",\"C2\") \narray_3d&lt;-array(v,c(3,4,2),dimnames = list(dim1,dim2,dim3)) \narray_3d\n#&gt; , , C1\n#&gt; \n#&gt;    B1 B2 B3 B4\n#&gt; A1  1  4  7 10\n#&gt; A2  2  5  8 11\n#&gt; A3  3  6  9 12\n#&gt; \n#&gt; , , C2\n#&gt; \n#&gt;    B1 B2 B3 B4\n#&gt; A1 13 16 19 22\n#&gt; A2 14 17 20 23\n#&gt; A3 15 18 21 24\nattributes(array_3d)\n#&gt; $dim\n#&gt; [1] 3 4 2\n#&gt; \n#&gt; $dimnames\n#&gt; $dimnames[[1]]\n#&gt; [1] \"A1\" \"A2\" \"A3\"\n#&gt; \n#&gt; $dimnames[[2]]\n#&gt; [1] \"B1\" \"B2\" \"B3\" \"B4\"\n#&gt; \n#&gt; $dimnames[[3]]\n#&gt; [1] \"C1\" \"C2\"\ndimnames(array_3d)\n#&gt; [[1]]\n#&gt; [1] \"A1\" \"A2\" \"A3\"\n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"B1\" \"B2\" \"B3\" \"B4\"\n#&gt; \n#&gt; [[3]]\n#&gt; [1] \"C1\" \"C2\"\n\n\n\n1.2.5 list\n从技术上讲，列表的每个元素实际上是相同的类型，因为每个元素实际上是对另一个对象的引用 Figure 1.1 ，该对象可以是任何类型。\n列表，list(name1=object1,name2=object2,...)\n\nCodemylist&lt;-list(title=\"My list\",\n             matr=matrix(c(\"a1\",\"b1\",\"a2\",\"b2\"),nrow=2,ncol=2,byrow=TRUE,\n                           dimnames = list(c(\"X1\",\"X2\"),c(\"Y1\",\"Y2\"))\n                         ),\n             df=data.frame(id=matrix(c(\"Lisa\",\"BOb\",\"John\",\"Jule\"),\n                                     nrow=4,ncol=1,byrow=TRUE\n                                     ),\n                           int=c(3,5,7,9),\n                           TF=c(T,T,T,F)\n                           ),\n             list=list(a=c(1,2,3),b=c(\"A\",\"B\"))\n             )\nmylist\n#&gt; $title\n#&gt; [1] \"My list\"\n#&gt; \n#&gt; $matr\n#&gt;    Y1   Y2  \n#&gt; X1 \"a1\" \"b1\"\n#&gt; X2 \"a2\" \"b2\"\n#&gt; \n#&gt; $df\n#&gt;     id int    TF\n#&gt; 1 Lisa   3  TRUE\n#&gt; 2  BOb   5  TRUE\n#&gt; 3 John   7  TRUE\n#&gt; 4 Jule   9 FALSE\n#&gt; \n#&gt; $list\n#&gt; $list$a\n#&gt; [1] 1 2 3\n#&gt; \n#&gt; $list$b\n#&gt; [1] \"A\" \"B\"\ntypeof(mylist)\n#&gt; [1] \"list\"\nattributes(mylist)\n#&gt; $names\n#&gt; [1] \"title\" \"matr\"  \"df\"    \"list\"\nclass(mylist)\n#&gt; [1] \"list\"\nnames(mylist)\n#&gt; [1] \"title\" \"matr\"  \"df\"    \"list\"\n\n\n\n1.2.6 data frame/tibble\n建立在\"list\"之上的两个最重要的 S3 向量是数据框和 tibble\n\n\n\n\n数据框是列向量具有 names，row.names ，class”data.frame” 属性的命名列表。\n与常规列表相比，数据框每个向量的长度必须相同。这为数据框提供了矩形结构，并解释了为什么它们共享矩阵和列表的属性\n\nCodeid&lt;-c(001231,001241,001413,001244) \nage&lt;-c(21,14,52,15) \ndiabetes&lt;-c(\"t1\",\"t2\",\"t1\",\"t1\") \nstatus&lt;-c(\"poor\",\"better\",\"best\",\"poor\") \ndf1&lt;-data.frame(patientID=id,age,diabetes,status,row.names = c(1,2,3,4),\n                stringsAsFactors = FALSE) # 4个列向量组成数据框 \ndf1\n\n\n\n\npatientID\nage\ndiabetes\nstatus\n\n\n\n1231\n21\nt1\npoor\n\n\n1241\n14\nt2\nbetter\n\n\n1413\n52\nt1\nbest\n\n\n1244\n15\nt1\npoor\n\n\n\n\n\nCodetypeof(df1)\n#&gt; [1] \"list\"\nattributes(df1)\n#&gt; $names\n#&gt; [1] \"patientID\" \"age\"       \"diabetes\"  \"status\"   \n#&gt; \n#&gt; $class\n#&gt; [1] \"data.frame\"\n#&gt; \n#&gt; $row.names\n#&gt; [1] \"1\" \"2\" \"3\" \"4\"\nclass(df1)\n#&gt; [1] \"data.frame\"\nnames(df1)\n#&gt; [1] \"patientID\" \"age\"       \"diabetes\"  \"status\"\ncolnames(df1)\n#&gt; [1] \"patientID\" \"age\"       \"diabetes\"  \"status\"\nrow.names(df1)\n#&gt; [1] \"1\" \"2\" \"3\" \"4\"\nrownames(df1)\n#&gt; [1] \"1\" \"2\" \"3\" \"4\"\n\n\ntibblle与data frame共享相同的结构。区别是class属性更多,不会自动进行强制类型转换，不会自动转换非法名称（自动反引号非法名称）， tibbles 只能循环较短的长度为 1 的向量，允许引用在构造过程中创建的变量。\n\nCodelibrary(tibble)\ndf2 &lt;- tibble(x = 1:3, y = letters[1:3])\ntypeof(df2)\n#&gt; [1] \"list\"\nattributes(df2)\n#&gt; $class\n#&gt; [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n#&gt; \n#&gt; $row.names\n#&gt; [1] 1 2 3\n#&gt; \n#&gt; $names\n#&gt; [1] \"x\" \"y\"\n\n\nnames(tibble(`1` = 1))\n#&gt; [1] \"1\"\n\ntibble(x = 1:4, y = 1)\n\n\n\n\nx\ny\n\n\n\n1\n1\n\n\n2\n1\n\n\n3\n1\n\n\n4\n1\n\n\n\n\n\nCode#tibble(x = 1:4, y = 1:2)\n#&gt; Error in `tibble()`:\n#&gt; ! Tibble columns must have compatible sizes.\n#&gt; • Size 4: Existing data.\n#&gt; • Size 2: Column `y`.\n#&gt; ℹ Only values of size one are recycled.\ntibble(\n  x = 1:3,\n  y = x * 2\n)\n\n\n\n\nx\ny\n\n\n\n1\n2\n\n\n2\n4\n\n\n3\n6\n\n\n\n\n\n\n\n1.2.6.1 行名→列\n\nCodedf3 &lt;- data.frame(\n  age = c(35, 27, 18),\n  hair = c(\"blond\", \"brown\", \"black\"),\n  row.names = c(\"Bob\", \"Susan\", \"Sam\")\n)\ndf3 |&gt; rownames_to_column(var = \"name\")\n\n\n\n\nname\nage\nhair\n\n\n\nBob\n35\nblond\n\n\nSusan\n27\nbrown\n\n\nSam\n18\nblack\n\n\n\n\n\nCodeas_tibble(df3, rownames = \"name\")\n\n\n\n\nname\nage\nhair\n\n\n\nBob\n35\nblond\n\n\nSusan\n27\nbrown\n\n\nSam\n18\nblack\n\n\n\n\n\nCode\n\nis_tibble(df2)\n#&gt; [1] TRUE\nis_tibble(df3)\n#&gt; [1] FALSE\nas_tibble(df3)\n\n\n\n\nage\nhair\n\n\n\n35\nblond\n\n\n27\nbrown\n\n\n18\nblack\n\n\n\n\n\n\n\n1.2.6.2 列表列\n\nCodedf &lt;- data.frame(x = 1:3)\ndf$y &lt;- list(1:2, 1:3, 1:4)\n\ndata.frame(\n  x = 1:3, \n  y = I(list(1:2, 1:3, 1:4))\n)\n\n\n\n\nx\ny\n\n\n\n1\n1, 2\n\n\n2\n1, 2, 3\n\n\n3\n1, 2, 3, 4\n\n\n\n\n\nCode\ntibble(\n  x = 1:3, \n  y = list(1:2, 1:3, 1:4)\n)\n\n\n\n\nx\ny\n\n\n\n1\n1, 2\n\n\n2\n1, 2, 3\n\n\n3\n1, 2, 3, 4\n\n\n\n\n\n\n\n1.2.7 矩阵和数据框列\n行数必须相等\n\nCodedfm &lt;- data.frame(\n  x = 1:3 * 10\n)\ndfm$y &lt;- matrix(1:9, nrow = 3)\ndfm$z &lt;- data.frame(a = 3:1, b = letters[1:3], stringsAsFactors = FALSE)\ndfm[1, ]\n\n\n\n\nx\ny\nz\n\n\n10\n1\n3",
    "crumbs": [
      "Programming",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>数据类型和数据结构</span>"
    ]
  },
  {
    "objectID": "basic_data_type_class.html#null",
    "href": "basic_data_type_class.html#null",
    "title": "\n1  数据类型和数据结构\n",
    "section": "\n1.3 NULL\n",
    "text": "1.3 NULL\n\n长度始终为零，并且没有属性。\n\nCodetypeof(NULL)\n#&gt; [1] \"NULL\"\nlength(NULL)\n#&gt; [1] 0\nis.null(NULL)\n#&gt; [1] TRUE\nc()\n#&gt; NULL",
    "crumbs": [
      "Programming",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>数据类型和数据结构</span>"
    ]
  },
  {
    "objectID": "function.html",
    "href": "function.html",
    "title": "\n2  函数\n",
    "section": "",
    "text": "2.1 函数组件\nsource reference srcref属性，指向用于创建函数的源代码\nCodef02 &lt;- function(x, y) {\n  # A comment\n  x + y\n}\n\nformals(f02)\n#&gt; $x\n#&gt; \n#&gt; \n#&gt; $y\nbody(f02)\n#&gt; {\n#&gt;     x + y\n#&gt; }\nenvironment(f02)\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\nattributes(f02)\n#&gt; $srcref\n#&gt; function(x, y) {\n#&gt;   # A comment\n#&gt;   x + y\n#&gt; }",
    "crumbs": [
      "Programming",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>函数</span>"
    ]
  },
  {
    "objectID": "function.html#函数组件",
    "href": "function.html#函数组件",
    "title": "\n2  函数\n",
    "section": "",
    "text": "formals() 控制如何调用函数的参数列表\n\nbody() 函数内部的代码\n\nenvironment() 确定函数如何查找与名称相关联的值的数据结构",
    "crumbs": [
      "Programming",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>函数</span>"
    ]
  },
  {
    "objectID": "function.html#sec-Primitive_functions",
    "href": "function.html#sec-Primitive_functions",
    "title": "\n2  函数\n",
    "section": "\n2.2 Primitive functions",
    "text": "2.2 Primitive functions\n函数有三个组件的规则有一个例外，Primitive functions ( 如sum()) 直接调用C code。\nPrimitive functions有内置builtin 和 特殊special 类型。\n\nCodesum\n#&gt; function (..., na.rm = FALSE)  .Primitive(\"sum\")\ntypeof(sum)\n#&gt; [1] \"builtin\"\n\n`[`\n#&gt; .Primitive(\"[\")\ntypeof(`[`)\n#&gt; [1] \"special\"\n\n\n这些函数主要存在于 C 中，而不是 R 中。Primitive functions仅在 base package 找到。\n\nCodeformals(sum)\n#&gt; NULL\nbody(sum)\n#&gt; NULL\nenvironment(sum)\n#&gt; NULL",
    "crumbs": [
      "Programming",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>函数</span>"
    ]
  },
  {
    "objectID": "function.html#first-class-functions",
    "href": "function.html#first-class-functions",
    "title": "\n2  函数\n",
    "section": "\n2.3 First-class functions",
    "text": "2.3 First-class functions\n\nCodef01 &lt;- function(x) {\n  sin(1 / x ^ 2)\n}\n\n\nanonymous function匿名函数\n\nCodelapply(mtcars, function(x) length(unique(x)))\n#&gt; $mpg\n#&gt; [1] 25\n#&gt; \n#&gt; $cyl\n#&gt; [1] 3\n#&gt; \n#&gt; $disp\n#&gt; [1] 27\n#&gt; \n#&gt; $hp\n#&gt; [1] 22\n#&gt; \n#&gt; $drat\n#&gt; [1] 22\n#&gt; \n#&gt; $wt\n#&gt; [1] 29\n#&gt; \n#&gt; $qsec\n#&gt; [1] 30\n#&gt; \n#&gt; $vs\n#&gt; [1] 2\n#&gt; \n#&gt; $am\n#&gt; [1] 2\n#&gt; \n#&gt; $gear\n#&gt; [1] 3\n#&gt; \n#&gt; $carb\n#&gt; [1] 6\n\n\n将函数放在列表中\n\nCodefuns &lt;- list(\n  half = function(x) x / 2,\n  double = function(x) x * 2\n)\nfuns$double(10)\n#&gt; [1] 20\n\n\n在 R 中，你经常会看到称为 闭包（closure） 的函数。\n\nCodetypeof(ggplot)\n#&gt; [1] \"closure\"",
    "crumbs": [
      "Programming",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>函数</span>"
    ]
  },
  {
    "objectID": "function.html#调用函数",
    "href": "function.html#调用函数",
    "title": "\n2  函数\n",
    "section": "\n2.4 调用函数",
    "text": "2.4 调用函数\n\nCodeargs &lt;- list(1:10, na.rm = TRUE)  # 参数列表\ndo.call(mean, args)\n#&gt; [1] 5.5",
    "crumbs": [
      "Programming",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>函数</span>"
    ]
  },
  {
    "objectID": "function.html#词法作用域",
    "href": "function.html#词法作用域",
    "title": "\n2  函数\n",
    "section": "\n2.5 词法作用域",
    "text": "2.5 词法作用域\nLexical scoping:\n\nName masking\nFunctions versus variables\nA fresh start\nDynamic lookup\n\n\n2.5.1 Name masking\n在函数内部定义的名称会掩盖在函数外部定义的名称。\n\nCodex &lt;- 10\ny &lt;- 20\ng02 &lt;- function() {\n  x &lt;- 1\n  y &lt;- 2\n  c(x, y)\n}\ng02()\n#&gt; [1] 1 2\n\n\n如果未在函数中定义名称，则 R 将向上查找。\n\nCodex &lt;- 2\ng03 &lt;- function() {\n  y &lt;- 1\n  c(x, y)\n}\ng03()\n#&gt; [1] 2 1\n\ny\n#&gt; [1] 20",
    "crumbs": [
      "Programming",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>函数</span>"
    ]
  },
  {
    "objectID": "function.html#惰性求值",
    "href": "function.html#惰性求值",
    "title": "\n2  函数\n",
    "section": "\n2.6 惰性求值",
    "text": "2.6 惰性求值\nLazy evaluation 是一种将操作延迟到真正需要它的结果时才执行的优化技术。\n惰性求值由称为 promise 或thunk 的数据结构提供支持。\n\n2.6.1 promise\n一个表达式，调用函数的环境，一个值\n\nCodedouble &lt;- function(x) { \n  message(\"Calculating...\")\n  x * 2\n}\n\nh03 &lt;- function(x) {\n  c(x, x)\n}\n\nh03(double(20))\n#&gt; Calculating...\n#&gt; [1] 40 40\n\n\n\n2.6.2 默认参数\n\nCodeh04 &lt;- function(x = 1, y = x * 2, z = a + b) {\n  a &lt;- 10\n  b &lt;- 100\n  \n  c(x, y, z)\n}\n\nh04()\n#&gt; [1]   1   2 110\n\n\n\n2.6.3 缺失参数\n\nCodeh06 &lt;- function(x = 10) {\n  list(missing(x), x)\n}\nstr(h06())\n#&gt; List of 2\n#&gt;  $ : logi TRUE\n#&gt;  $ : num 10\n\nstr(h06(10))\n#&gt; List of 2\n#&gt;  $ : logi FALSE\n#&gt;  $ : num 10",
    "crumbs": [
      "Programming",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>函数</span>"
    ]
  },
  {
    "objectID": "function.html#特殊参数...",
    "href": "function.html#特殊参数...",
    "title": "\n2  函数\n",
    "section": "\n2.7 特殊参数...\n",
    "text": "2.7 特殊参数...\n\nvariable arguments，有了它，函数可以接受任意数量的附加参数。还可以将附加参数传递给另一个函数\n\nCodei01 &lt;- function(y, z) {\n  list(y = y, z = z)\n}\n\ni02 &lt;- function(x, ...) {\n  i01(...)\n}\nstr(i02(x = 1, y = 2, z = 3))\n#&gt; List of 2\n#&gt;  $ y: num 2\n#&gt;  $ z: num 3\n\n\n特殊形式 ..N，按位置引用参数\n\nCodei03 &lt;- function(...) {\n  list(first = ..1, third = ..3)\n}\nstr(i03(1, 2, 3))\n#&gt; List of 2\n#&gt;  $ first: num 1\n#&gt;  $ third: num 3\n\n\nlist(...)计算参数并将它们存储在列表中\n\nCodei04 &lt;- function(...) {\n  list(...)\n}\nstr(i04(a = 1, b = 2))\n#&gt; List of 2\n#&gt;  $ a: num 1\n#&gt;  $ b: num 2",
    "crumbs": [
      "Programming",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>函数</span>"
    ]
  },
  {
    "objectID": "function.html#退出函数",
    "href": "function.html#退出函数",
    "title": "\n2  函数\n",
    "section": "\n2.8 退出函数",
    "text": "2.8 退出函数\n返回一个对象，或者，错误\n\n2.8.1 隐式返回值\n最后计算的表达式是返回值\n\nCodej01 &lt;- function(x) {\n  if (x &lt; 10) {\n    0\n  } else {\n    10\n  }\n}\nj01(5)\n#&gt; [1] 0\n\nj01(15)\n#&gt; [1] 10\n\n\n\n2.8.2 显示返回值\n调用return()\n\nCodej02 &lt;- function(x) {\n  if (x &lt; 10) {\n    return(0)\n  } else {\n    return(10)\n  }\n}\n\n\n\n2.8.3 不可见值\n大多数函数都以可见方式返回：在交互式上下文中调用函数会自动打印结果\n\nCodej03 &lt;- function() 1\nj03()\n#&gt; [1] 1\n\n\n通过应用invisible()于最后一个值来阻止自动打印：\n\nCodej04 &lt;- function() invisible(1)\nj04()\n\n\n若要验证此值是否确实存在，可以显式打印它或将其括在括号中,或者使用返回值和可见性标志：withVisible()\n\nCodeprint(j04())\n#&gt; [1] 1\n\n\n(j04())\n#&gt; [1] 1\n\nwithVisible(j04())\n#&gt; $value\n#&gt; [1] 1\n#&gt; \n#&gt; $visible\n#&gt; [1] FALSE\n\n\n不可见返回的最常见函数是：&lt;-\n\nCodea &lt;- 2\n(a &lt;- 2)\n#&gt; [1] 2\n\na &lt;- b &lt;- c &lt;- d &lt;- 2\n\n\n\n2.8.4 Errors\n如果函数无法完成其分配的任务，则应抛出错误，并立即终止函数的执行。\n\nCodej05 &lt;- function() {\n  stop(\"I'm an error\")\n  return(10)\n}\nj05()\n#&gt; Error in j05(): I'm an error\n\n\n\n2.8.5 退出处理程序\n\nCodej06 &lt;- function(x) {\n  cat(\"Hello\\n\")\n  on.exit(cat(\"Goodbye!\\n\"), add = TRUE) # 使用  add = TRUE 时始终设置\n  \n  if (x) {\n    return(10)\n  } else {\n    stop(\"Error\")\n  }\n}\n\nj06(TRUE)\n#&gt; Hello\n#&gt; Goodbye!\n#&gt; [1] 10\n\n\nj06(FALSE)\n#&gt; Hello\n#&gt; Error in j06(FALSE): Error\n#&gt; Goodbye!",
    "crumbs": [
      "Programming",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>函数</span>"
    ]
  },
  {
    "objectID": "function.html#函数形式",
    "href": "function.html#函数形式",
    "title": "\n2  函数\n",
    "section": "\n2.9 函数形式",
    "text": "2.9 函数形式\n\nprefix： foofy(a, b, c)\n\ninfix： x + y\n\nreplacement：names(df) &lt;- c(\"a\", \"b\", \"c\")\n\nspecial：[[, if ,for\n\n\n\nCodex + y\n#&gt; [1] 22\n`+`(x, y)\n#&gt; [1] 22\n\nnames(df) &lt;- c(\"x\", \"y\", \"z\")\n#&gt; Error in names(df) &lt;- c(\"x\", \"y\", \"z\"): names() applied to a non-vector\n`names&lt;-`(df, c(\"x\", \"y\", \"z\"))\n#&gt; Error in eval(expr, envir, enclos): names() applied to a non-vector\n\nfor(i in 1:10) print(i)\n#&gt; [1] 1\n#&gt; [1] 2\n#&gt; [1] 3\n#&gt; [1] 4\n#&gt; [1] 5\n#&gt; [1] 6\n#&gt; [1] 7\n#&gt; [1] 8\n#&gt; [1] 9\n#&gt; [1] 10\n`for`(i, 1:10, print(i))\n#&gt; [1] 1\n#&gt; [1] 2\n#&gt; [1] 3\n#&gt; [1] 4\n#&gt; [1] 5\n#&gt; [1] 6\n#&gt; [1] 7\n#&gt; [1] 8\n#&gt; [1] 9\n#&gt; [1] 10\n\n\n\n2.9.1 前缀形式\n是 R 代码中最常见的形式，参数按确切名称匹配，然后与唯一前缀匹配，最后按位置匹配。\n\nCodek01 &lt;- function(abcdef, bcde1, bcde2) {\n  list(a = abcdef, b1 = bcde1, b2 = bcde2)\n}\nstr(k01(2, 3, abcdef = 1))\n#&gt; List of 3\n#&gt;  $ a : num 1\n#&gt;  $ b1: num 2\n#&gt;  $ b2: num 3\nstr(k01(2, 3, a = 1))  # 部分匹配\n#&gt; List of 3\n#&gt;  $ a : num 1\n#&gt;  $ b1: num 2\n#&gt;  $ b2: num 3\noptions(warnPartialMatchArgs = TRUE)\nx &lt;- k01(a = 1, 2, 3)\n#&gt; Warning in k01(a = 1, 2, 3): partial argument match of 'a' to 'abcdef'\n\n\n\n2.9.2 中缀形式\n\nCode`%+%` &lt;- function(a, b) paste0(a, b)\n\"new \" %+% \"string\"\n#&gt; [1] \"new string\"\n\n\n\n2.9.3 替换形式\n\nCode`second&lt;-` &lt;- function(x, value) {\n  x[2] &lt;- value\n  x\n}\nx &lt;- 1:10\nsecond(x) &lt;- 5L\nx\n#&gt;  [1]  1  5  3  4  5  6  7  8  9 10\n\n\n\n2.9.4 特殊形式\n所有特殊形式都作为Primitive functions Section 2.2 实现（即在 C 中），这意味着打印这些函数没有信息。\n\nCode`for`\n#&gt; .Primitive(\"for\")\nformals(`for`)\n#&gt; NULL",
    "crumbs": [
      "Programming",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>函数</span>"
    ]
  },
  {
    "objectID": "efficient.html",
    "href": "efficient.html",
    "title": "\n3  高效\n",
    "section": "",
    "text": "3.1 稀疏矩阵\n稀疏矩阵(Sparse matrices)对象仅存储非零元素，更节省内存\nCodelibrary(\"Matrix\")\nN = 100\n\nm = diag(1, N, N)\nsp = sparseMatrix(1:N, 1:N, x = 1)\n \nobject.size(m)\n#&gt; 80216 bytes\nobject.size(sp)\n#&gt; 3104 bytes",
    "crumbs": [
      "Programming",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>高效</span>"
    ]
  },
  {
    "objectID": "efficient.html#并行计算",
    "href": "efficient.html#并行计算",
    "title": "\n3  高效\n",
    "section": "\n3.2 并行计算",
    "text": "3.2 并行计算\nParallel computing\n\nCodelibrary(\"parallel\")\nno_of_cores = detectCores()\nno_of_cores\n#&gt; [1] 8\n\n\nparLapply（cl， x， FUN， ...）\nparApply（cl = NULL， X， MARGIN， FUN， ...）\nparSapply（cl = NULL， X， FUN， ...， simplify = TRUE， USE.NAMES = TRUE)\nmakeCluster()此函数指定要使用的处理器数量\n\nCodelibrary(\"parallel\")\n\n\nN = 10^4\nsapply(1:N, sd)\n\ncl = makeCluster(4)\nparSapply(cl, 1:N, sd)\nstopCluster(cl)",
    "crumbs": [
      "Programming",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>高效</span>"
    ]
  },
  {
    "objectID": "efficient.html#rcpp",
    "href": "efficient.html#rcpp",
    "title": "\n3  高效\n",
    "section": "\n3.3 Rcpp",
    "text": "3.3 Rcpp\nRcpp\nRcpp sugar\nNumericVector IntegerVector CharacterVector LogicalVector\nNumericMatrix IntegerMatrix CharacterMatrix LogicalMatrix\n\nCodelibrary(Rcpp)\nsourceCpp(\"function/add_cpp.cpp\")\n#&gt; \n#&gt; &gt; add_cpp(1, 2)\n#&gt; [1] 3\n\nadd_cpp(2,34.5)\n#&gt; [1] 36.5\n\nsourceCpp(\"function/mean_cpp.cpp\")\n#&gt; \n#&gt; &gt; x = c(1, 2, 3, 4, 5)\n#&gt; \n#&gt; &gt; mean_cpp(x)\n#&gt; [1] 3",
    "crumbs": [
      "Programming",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>高效</span>"
    ]
  },
  {
    "objectID": "efficient.html#rcpp-sugar",
    "href": "efficient.html#rcpp-sugar",
    "title": "\n3  高效\n",
    "section": "\n3.4 Rcpp sugar",
    "text": "3.4 Rcpp sugar",
    "crumbs": [
      "Programming",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>高效</span>"
    ]
  },
  {
    "objectID": "efficient.html#硬件",
    "href": "efficient.html#硬件",
    "title": "\n3  高效\n",
    "section": "\n3.5 硬件",
    "text": "3.5 硬件\n\nCodelibrary(\"benchmarkme\")\n\n\n1字节（byte）= 8位（bit） 二进制数 = 1个 ASCII 字符。\nInternational System of Units (SI)\n1 kilobyte (kB) =(2^{10}) bytes\n1 megabyte (MB) = (2{10}) kilobytes= (2{20}) bytes\n\nCode# 随机存取存储器 Random access memory,RAM\nbenchmarkme::get_ram()\n#&gt; 6.32 GB\n\n\nstandard hard disk drives (HDDs)\nSolid state drives (SSDs)\n\nCode# 操作系统 2^8\n.Machine$sizeof.pointer\n#&gt; [1] 8\n\n\n\nCode# CPU\nres = benchmark_std() \nplot(res)\n\n\n\n\n\n\n#&gt; Press return to get next plot\n\n\n\n\n\n\n#&gt; Press return to get next plot",
    "crumbs": [
      "Programming",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>高效</span>"
    ]
  },
  {
    "objectID": "I-O.html",
    "href": "I-O.html",
    "title": "\n4  读入和写出\n",
    "section": "",
    "text": "4.1 Import",
    "crumbs": [
      "Data science",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>读入和写出</span>"
    ]
  },
  {
    "objectID": "I-O.html#import",
    "href": "I-O.html#import",
    "title": "\n4  读入和写出\n",
    "section": "",
    "text": "4.1.1 键盘输入\n\nCodedf &lt;- data.frame(id=character(0),age=numeric(0),sex=character(0))\ndf &lt;- edit(df)\n\nfix(df)\n\n\n\n4.1.2 文本文件\n常用的分隔符如逗号, ，制表符\\t，分号;，空格space，…… 等。\n\n4.1.2.1 utils:: utilities,a piece of computer software that performs a particular task\nread.table() read.csv() read.csv2\n\nCode# 列名(第1行),行标识符 (第1列)\nutils::read.table(\"data/leadership.txt\",header = TRUE,sep=\",\",row.names = 1)\n\n\n\n\n\ndate\ncountry\ngender\nage\nq1\nq2\nq3\nq4\nq5\n\n\n\nBob\n10/24/14\nUS\nM\n29\n5\n4\n5\n5\n5\n\n\nMary\n10/28/14\nUS\nF\n44\n3\n5\n2\n5\n5\n\n\nLily\n10/01/14\nUK\nF\n45\n3\n5\n5\n5\n2\n\n\nJuly\n10/12/14\nUK\nM\n68\n3\n3\n4\nNA\nNA\n\n\nFrank\n05/01/14\nUK\nF\n99\n2\n2\n1\n2\n1\n\n\n\n\n\nCodex &lt;- read.csv(\"data/leadership.txt\",header = TRUE,sep=\",\",row.names = 1)\nread.table(\"data/leadership.txt\",header = TRUE,sep=\",\",row.names = \"id\") \n\n\n\n\n\ndate\ncountry\ngender\nage\nq1\nq2\nq3\nq4\nq5\n\n\n\nBob\n10/24/14\nUS\nM\n29\n5\n4\n5\n5\n5\n\n\nMary\n10/28/14\nUS\nF\n44\n3\n5\n2\n5\n5\n\n\nLily\n10/01/14\nUK\nF\n45\n3\n5\n5\n5\n2\n\n\nJuly\n10/12/14\nUK\nM\n68\n3\n3\n4\nNA\nNA\n\n\nFrank\n05/01/14\nUK\nF\n99\n2\n2\n1\n2\n1\n\n\n\n\n\n\n\n4.1.2.2 readr::\n\nread.csv2() read_tsv() read_delim()\n\nCodereadr::read_csv(\"data/leadership.txt\",col_names = TRUE,id=\"file_path\") |&gt; \n    column_to_rownames(var = \"id\")\n\n\n\n4.1.3 Excel\n\nCodelibrary(readxl)\n#read_xls()\n#read_xlsx()\nread_excel(path = \"data/example.xlsx\",sheet = 1,range = \"A1:D11\")\n\n\n\n\n姓名\n数学\n科学\n英语\n\n\n\nJ.D\n502\n95\n25\n\n\nA.W\n600\n99\n22\n\n\nB.M\n412\n80\n18\n\n\nD.J\n358\n82\n15\n\n\nJ.M\n495\n75\n20\n\n\nC.C\n512\n85\n28\n\n\nR.y\n410\n80\n15\n\n\nG.K\n625\n95\n30\n\n\nJ.E\n573\n89\n27\n\n\nM.R\n522\n86\n18\n\n\n\n\n\nCoderead_excel(\"data/example.xlsx\",2)\n\n\n\n\nID\nTime\nX1\nX2\n\n\n\n1\n1\n5\n6\n\n\n1\n2\n3\n5\n\n\n2\n1\n6\n1\n\n\n2\n2\n2\n4\n\n\n\n\n\n\n\n4.1.4 Internet datasets\n\nCodeurl = \"https://www.monetdb.org/sites/default/files/voc_tsvs.zip\"\ndownload.file(url, \"voc_tsvs.zip\") # download file\nunzip(\"voc_tsvs.zip\", exdir = \"data\") # unzip files\nfile.remove(\"voc_tsvs.zip\") # tidy up by removing the zip file\n\nurl = \"https://vincentarelbundock.github.io/Rdatasets/csv/datasets/co2.csv\"\ndownload.file(url, \"extdata/co2.csv\")\ndf_co2 = read_csv(\"extdata/co2.csv\")\n\n\n\n4.1.5 library datasets\n\nCode#|eval: false\ndata(package = \"dplyr\")\n#&gt; Data sets in package ‘dplyr’:\n#&gt; \n#&gt; band_instruments               Band membership\n#&gt; band_instruments2              Band membership\n#&gt; band_members                   Band membership\n#&gt; starwars                       Starwars characters\n#&gt; storms                         Storm tracks data\n\n\n\n4.1.6 二进制文件\nRDS,R’s custom binary format called RDS\nread_rds()\n\nCodewrite_rds(x,file = \"data/leadership.parquet\")\nread_rds(\"data/leadership.rds\")\n\n\n\n\n\ndate\ncountry\ngender\nage\nq1\nq2\nq3\nq4\nq5\n\n\n\nBob\n10/24/14\nUS\nM\n29\n5\n4\n5\n5\n5\n\n\nMary\n10/28/14\nUS\nF\n44\n3\n5\n2\n5\n5\n\n\nLily\n10/01/14\nUK\nF\n45\n3\n5\n5\n5\n2\n\n\nJuly\n10/12/14\nUK\nM\n68\n3\n3\n4\nNA\nNA\n\n\nFrank\n05/01/14\nUK\nF\n99\n2\n2\n1\n2\n1\n\n\n\n\n\n\nParquet,a fast binary and columnar storage file format(列式存储文件)\n\nCodelibrary(arrow)\nwrite_parquet(x,sink = \"data/leadership.parquet\")\nread_parquet(file = \"data/leadership.parquet\" )\n\n\n\n\ndate\ncountry\ngender\nage\nq1\nq2\nq3\nq4\nq5\n\n\n\n10/24/14\nUS\nM\n29\n5\n4\n5\n5\n5\n\n\n10/28/14\nUS\nF\n44\n3\n5\n2\n5\n5\n\n\n10/01/14\nUK\nF\n45\n3\n5\n5\n5\n2\n\n\n10/12/14\nUK\nM\n68\n3\n3\n4\nNA\nNA\n\n\n05/01/14\nUK\nF\n99\n2\n2\n1\n2\n1\n\n\n\n\n\n\n\n4.1.7 JSON\njavascript object notation\n\nCodelibrary(jsonlite)\nread_json(path = \"data/3龙门币3赤金.json\",simplifyVector = TRUE)\n#&gt; $author\n#&gt; [1] \"wal\"\n#&gt; \n#&gt; $description\n#&gt; [1] \"\"\n#&gt; \n#&gt; $id\n#&gt; [1] 1.71086e+15\n#&gt; \n#&gt; $title\n#&gt; [1] \"3龙门币3赤金\"\n#&gt; \n#&gt; $buildingType\n#&gt; [1] 243\n#&gt; \n#&gt; $planTimes\n#&gt; [1] \"3班\"\n#&gt; \n#&gt; $plans\n#&gt;    name description Fiammetta.enable Fiammetta.target Fiammetta.order\n#&gt; 1 A白班                         TRUE             巫恋             pre\n#&gt; 2 B夜班                         TRUE           龙舌兰             pre\n#&gt;   drones.room drones.index drones.enable drones.order\n#&gt; 1     trading            1          TRUE          pre\n#&gt; 2     trading            1          TRUE          pre\n#&gt;                                                                                                                                      rooms.trading\n#&gt; 1         FALSE, FALSE, FALSE, LMD, LMD, LMD, 巫恋, 龙舌兰, 柏喙, 孑, 银灰, 琳琅诗怀雅, 空弦, 但书, 伺夜, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE\n#&gt; 2 FALSE, FALSE, FALSE, LMD, LMD, LMD, 巫恋, 龙舌兰, 卡夫卡, 能天使, 德克萨斯, 拉普兰德, 黑键, 慕斯, 石英, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE\n#&gt;                                                                                                                                              rooms.manufacture\n#&gt; 1         FALSE, FALSE, FALSE, Pure Gold, Pure Gold, Pure Gold, 槐琥, 至简, 清流, 苍苔, 斑点, 夜烟, 温蒂, 森蚺, 异客, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE\n#&gt; 2 FALSE, FALSE, FALSE, Pure Gold, Pure Gold, Pure Gold, 淬羽赫默, 多萝西, 白面鸮, 砾, 迷迭香, 香草, 火神, 贝娜, 泡泡, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE\n#&gt;                                                                               rooms.power\n#&gt; 1 FALSE, FALSE, FALSE, 承曦格雷伊, 澄闪, 格雷伊, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE\n#&gt; 2       FALSE, FALSE, FALSE, 缪尔赛思, 雷蛇, 黍, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE\n#&gt;                                                                                  rooms.dormitory\n#&gt; 1 FALSE, FALSE, FALSE, FALSE, 菲亚梅塔, 重岳, FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE\n#&gt; 2 FALSE, FALSE, FALSE, FALSE, 菲亚梅塔, 塑心, FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE\n#&gt;                                                     rooms.control\n#&gt; 1 FALSE, 阿米娅, 麒麟R夜刀, 火龙S黑角, 灵知, 玛恩纳, FALSE, FALSE\n#&gt; 2             FALSE, 重岳, 诗怀雅, 凯尔希, 令, 琴柳, FALSE, FALSE\n#&gt;                       rooms.meeting                    rooms.hire\n#&gt; 1     FALSE, 陈, 白雪, FALSE, FALSE FALSE, 艾雅法拉, FALSE, FALSE\n#&gt; 2 FALSE, 远山, 塞雷娅, FALSE, FALSE     FALSE, 絮雨, FALSE, FALSE\n#&gt;          rooms.processing                     period\n#&gt; 1     FALSE, FALSE, FALSE               07:00, 21:59\n#&gt; 2 FALSE, 年, FALSE, FALSE 22:00, 00:00, 23:59, 06:59\n#&gt; \n#&gt; $scheduleType\n#&gt; $scheduleType$planTimes\n#&gt; [1] 2\n#&gt; \n#&gt; $scheduleType$trading\n#&gt; [1] 3\n#&gt; \n#&gt; $scheduleType$manufacture\n#&gt; [1] 3\n#&gt; \n#&gt; $scheduleType$power\n#&gt; [1] 3\n#&gt; \n#&gt; $scheduleType$dormitory\n#&gt; [1] 4\n\n\n\n4.1.8 SPSS/SAS/stata DTA\n\nCodelibrary(haven)\nread_spss()\nread_sav()\n\nread_sas()\n\nread_dta()\nread_stata()\n\n\n\n4.1.9 Database\n\nCodelibrary(DBI)\nlibrary(dbplyr)\n\n\n\n4.1.10 脚本载入\n\nCodesource(\"data/add_function.R\")\nadd(c(1,24,4),4)\n#&gt; [1]  5 28  8\nsource(\"data/add_function\")\n#&gt; Error in file(filename, \"r\", encoding = encoding): cannot open the connection\n\n\n\n\n\n\n\n\nadd_function\n\nCodeadd &lt;- function(x,y){\n  return(x+y)\n}",
    "crumbs": [
      "Data science",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>读入和写出</span>"
    ]
  },
  {
    "objectID": "I-O.html#write",
    "href": "I-O.html#write",
    "title": "\n4  读入和写出\n",
    "section": "\n4.2 Write",
    "text": "4.2 Write\n\n4.2.1 文本输出\n\nCode#|eval: false \nwrite_csv()\n#&gt; Error in write_csv(): argument \"x\" is missing, with no default\nwrite_xlsx()\n#&gt; Error in write_xlsx(): argument \"x\" is missing, with no default\nwrite_rds()\n#&gt; Error in file(file, ...): argument \"file\" is missing, with no default\nwrite_parquet()\n#&gt; Error in write_parquet(): argument \"x\" is missing, with no default\n\n\n\nCode#|eval: false \nsink(\"data/sink_output.txt\",append = F,split = T)  # split =T 输出到控制台和文件\nletters\n#&gt;  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n#&gt; [20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\nsink(NULL)\n\n\n\n4.2.2 图片输出\n\nCode#|eval: false \npdf(file = \"data/pdf_output.pdf\")       # bmp,jpeg,png，SVG\nplot(1:25,1:25,pch=1:25,col=\"green\",bg=\"red\",type = \"b\")\nwhile(!is.null(dev.list()))  dev.off()",
    "crumbs": [
      "Data science",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>读入和写出</span>"
    ]
  },
  {
    "objectID": "base_data_processing.html",
    "href": "base_data_processing.html",
    "title": "\n5  基本数据处理\n",
    "section": "",
    "text": "5.1 subsetting operators\n[，$，[[\nS4 对象： @ slot",
    "crumbs": [
      "Data science",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>基本数据处理</span>"
    ]
  },
  {
    "objectID": "base_data_processing.html#subsetting-operators",
    "href": "base_data_processing.html#subsetting-operators",
    "title": "\n5  基本数据处理\n",
    "section": "",
    "text": "5.1.1 [ ]\n\n\nCodex &lt;- c(2.1, 4.2, 3.3, 5.4)\n\nx[c(3, 1)]\n#&gt; [1] 3.3 2.1\n\nx[-c(3, 1)]\n#&gt; [1] 4.2 5.4\n\nx[c(TRUE, TRUE, FALSE, FALSE)]\n#&gt; [1] 2.1 4.2\nx[x &gt; 3]\n#&gt; [1] 4.2 3.3 5.4\n\nx[c(TRUE, FALSE)] # recycling rules 循环\n#&gt; [1] 2.1 3.3\n\nx[]\n#&gt; [1] 2.1 4.2 3.3 5.4\n\nx[0]\n#&gt; numeric(0)\n\n\n\n5.1.2 $ [[]]\n\n$是一个简写运算符, x$y大致相当于 x[[\"y\"]] ,从左到右部分匹配\n\nCodex &lt;- list(abc = 1)\nx$a\n#&gt; [1] 1\n\nx[[\"a\"]]\n#&gt; NULL\n\noptions(warnPartialMatchDollar = TRUE)\nx$a\n#&gt; [1] 1\n\n\n\n5.1.3 subset(),sample()\n\n\nCodesubset()\nsample()\n\n\n\n5.1.4 逻辑子集\n\nCodex&lt;-c(2,3,5,1,4)\nall(x&gt;2)\n#&gt; [1] FALSE\nany(x&gt;2)\n#&gt; [1] TRUE\nwhich(x&gt;2)\n#&gt; [1] 2 3 5\nwhich.max(x)\n#&gt; [1] 3\nwhich.min(x)\n#&gt; [1] 4\nmtcars[mtcars$gear == 5 & mtcars$cyl == 4, ]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n\nPorsche 914-2\n26.0\n4\n120.3\n91\n4.43\n2.140\n16.7\n0\n1\n5\n2\n\n\nLotus Europa\n30.4\n4\n95.1\n113\n3.77\n1.513\n16.9\n1\n1\n5\n2",
    "crumbs": [
      "Data science",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>基本数据处理</span>"
    ]
  },
  {
    "objectID": "base_data_processing.html#布尔运算和集合运算",
    "href": "base_data_processing.html#布尔运算和集合运算",
    "title": "\n5  基本数据处理\n",
    "section": "\n5.2 布尔运算和集合运算",
    "text": "5.2 布尔运算和集合运算\n\nCode(x1 &lt;- 1:10 %% 2 == 0)\n#&gt;  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE\n(x2 &lt;- which(x1))\n#&gt; [1]  2  4  6  8 10\n\n(y1 &lt;- 1:10 %% 5 == 0)\n#&gt;  [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE\n(y2 &lt;- which(y1))\n#&gt; [1]  5 10\n\nx1 & y1\n#&gt;  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\nbase::intersect(x2, y2)\n#&gt; [1] 10\n\nx1 | y1\n#&gt;  [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE\nbase::union(x2,y2)\n#&gt; [1]  2  4  6  8 10  5\n\nx1 & !y1\n#&gt;  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE\nbase::setdiff(x2, y2)\n#&gt; [1] 2 4 6 8\n\nxor(x1, y1)\n#&gt;  [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE\nbase::setdiff(base::union(x2, y2), base::intersect(x2, y2))\n#&gt; [1] 2 4 6 8 5",
    "crumbs": [
      "Data science",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>基本数据处理</span>"
    ]
  },
  {
    "objectID": "base_data_processing.html#排序",
    "href": "base_data_processing.html#排序",
    "title": "\n5  基本数据处理\n",
    "section": "\n5.3 排序",
    "text": "5.3 排序\n\nCodex &lt;- c(\"b\", \"c\", \"a\")\norder(x)\n#&gt; [1] 3 1 2\nx[order(x)]\n#&gt; [1] \"a\" \"b\" \"c\"\n\n\n\nCodesort()\ndplyr::arrange()",
    "crumbs": [
      "Data science",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>基本数据处理</span>"
    ]
  },
  {
    "objectID": "base_data_processing.html#seq-rep-cut",
    "href": "base_data_processing.html#seq-rep-cut",
    "title": "\n5  基本数据处理\n",
    "section": "\n5.4 seq(), rep(), cut()\n",
    "text": "5.4 seq(), rep(), cut()\n\n\nCodeseq(from=1,to=30,by=3)  # 生成一个序列\n#&gt;  [1]  1  4  7 10 13 16 19 22 25 28\nseq(from=1,to=30,length=10) \n#&gt;  [1]  1.000000  4.222222  7.444444 10.666667 13.888889 17.111111 20.333333\n#&gt;  [8] 23.555556 26.777778 30.000000\n\nrep(x = c(\"A\",1,\"B\",2),times = 3)           #重复序列\n#&gt;  [1] \"A\" \"1\" \"B\" \"2\" \"A\" \"1\" \"B\" \"2\" \"A\" \"1\" \"B\" \"2\"\nrep(x = c(\"A\",1,\"B\",2),times = c(1,2,3,4))\n#&gt;  [1] \"A\" \"1\" \"1\" \"B\" \"B\" \"B\" \"2\" \"2\" \"2\" \"2\"\nrep(x = c(\"A\",1,\"B\",2),each = 3,times = 2)\n#&gt;  [1] \"A\" \"A\" \"A\" \"1\" \"1\" \"1\" \"B\" \"B\" \"B\" \"2\" \"2\" \"2\" \"A\" \"A\" \"A\" \"1\" \"1\" \"1\" \"B\"\n#&gt; [20] \"B\" \"B\" \"2\" \"2\" \"2\"\n\nx &lt;- c(2.3,4.5,2.4,3,3.8,4,5.6,6.7,2.1,1.5)\ncut( x = x, breaks =3,)                # 因子\n#&gt;  [1] (1.49,3.23] (3.23,4.97] (1.49,3.23] (1.49,3.23] (3.23,4.97] (3.23,4.97]\n#&gt;  [7] (4.97,6.71] (4.97,6.71] (1.49,3.23] (1.49,3.23]\n#&gt; Levels: (1.49,3.23] (3.23,4.97] (4.97,6.71]\ncut( x = x, breaks =c(1,3,5,8),include.lowest = TRUE) \n#&gt;  [1] [1,3] (3,5] [1,3] [1,3] (3,5] (3,5] (5,8] (5,8] [1,3] [1,3]\n#&gt; Levels: [1,3] (3,5] (5,8]",
    "crumbs": [
      "Data science",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>基本数据处理</span>"
    ]
  },
  {
    "objectID": "base_data_processing.html#数学函数",
    "href": "base_data_processing.html#数学函数",
    "title": "\n5  基本数据处理\n",
    "section": "\n5.5 数学函数",
    "text": "5.5 数学函数\n\nCodex&lt;-c(25,-4,3.66,3.42,-5.99)\nabs(x)                       #绝对值\n#&gt; [1] 25.00  4.00  3.66  3.42  5.99\nsqrt(x)                      #平方根\n#&gt; [1] 5.000000      NaN 1.913113 1.849324      NaN\nceiling(x)                   #向上取整\n#&gt; [1] 25 -4  4  4 -5\nfloor(x)                     #向下取整\n#&gt; [1] 25 -4  3  3 -6\ntrunc(x)                     #整数部分\n#&gt; [1] 25 -4  3  3 -5\nround(x,digits = 2)          #四舍五入，保留2位小数\n#&gt; [1] 25.00 -4.00  3.66  3.42 -5.99\nsignif(x,digits = 2)         #四舍五入，保留2有效数字\n#&gt; [1] 25.0 -4.0  3.7  3.4 -6.0\nlog(x,base=4)                #对x取以base为底的对数\n#&gt; [1] 2.3219281       NaN 0.9359218 0.8869982       NaN\nlog(x)                          #自然对数\n#&gt; [1] 3.218876      NaN 1.297463 1.229641      NaN\nlog10(x)                        #常用对数\n#&gt; [1] 1.3979400       NaN 0.5634811 0.5340261       NaN\nexp(x)                       #e指数函数\n#&gt; [1] 7.200490e+10 1.831564e-02 3.886134e+01 3.056942e+01 2.503664e-03",
    "crumbs": [
      "Data science",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>基本数据处理</span>"
    ]
  },
  {
    "objectID": "base_data_processing.html#统计函数",
    "href": "base_data_processing.html#统计函数",
    "title": "\n5  基本数据处理\n",
    "section": "\n5.6 统计函数",
    "text": "5.6 统计函数\n\nCodemean(x,trim = 0.05,na.rm = TRUE)     #算术平均值\n#&gt; [1] 4.418\nmedian(x)                            #中位数\n#&gt; [1] 3.42\nsd(x)                                #标准差\n#&gt; [1] 12.29206\nvar(x)                               #方差\n#&gt; [1] 151.0946\nmad(x)                               #绝对中位差\n#&gt; [1] 11.00089\nquantile(x,probs = c(0,0.25,0.5,0.75,1))     #分位数\n#&gt;    0%   25%   50%   75%  100% \n#&gt; -5.99 -4.00  3.42  3.66 25.00\nrange(x)                             # 值域\n#&gt; [1] -5.99 25.00\nscale(x,center = TRUE,scale = TRUE)  #标准化（均值为0、标准差为1）\n#&gt;             [,1]\n#&gt; [1,]  1.67441487\n#&gt; [2,] -0.68483259\n#&gt; [3,] -0.06166585\n#&gt; [4,] -0.08119065\n#&gt; [5,] -0.84672578\n#&gt; attr(,\"scaled:center\")\n#&gt; [1] 4.418\n#&gt; attr(,\"scaled:scale\")\n#&gt; [1] 12.29206\nscale(x,center = TRUE,scale =FALSE)  #中心化：减去均值\n#&gt;         [,1]\n#&gt; [1,]  20.582\n#&gt; [2,]  -8.418\n#&gt; [3,]  -0.758\n#&gt; [4,]  -0.998\n#&gt; [5,] -10.408\n#&gt; attr(,\"scaled:center\")\n#&gt; [1] 4.418\n\n\nx &lt;- c(1,3,5,7,9,11,13)\n# Find the \"previous\" (lag()) or \"next\" (lead()) values in a vector\ndplyr::lag(x,n=2)                      # n阶滞后\n#&gt; [1] NA NA  1  3  5  7  9\ndplyr::lead(x,n=2)                     # n阶前移\n#&gt; [1]  5  7  9 11 13 NA NA\n\n# 滞后差分  lag阶滞后  difference阶差分\ndiff(x,lag = 1,difference=1)     # 隔0个值后位减前位，进行1次\n#&gt; [1] 2 2 2 2 2 2\ndiff(x,lag = 1,difference=2)     ## 隔0个值后位减前位，进行2次\n#&gt; [1] 0 0 0 0 0\ndiff(x,lag = 1,difference=3)     # 隔0个值后位减前位，进行3次\n#&gt; [1] 0 0 0 0\n\ndiff(x,lag = 2,difference=1)  # 隔1个值后位减前位，进行1次\n#&gt; [1] 4 4 4 4 4\ndiff(x,lag = 2,difference=2) ## 隔1个值后位减前位，进行2次\n#&gt; [1] 0 0 0",
    "crumbs": [
      "Data science",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>基本数据处理</span>"
    ]
  },
  {
    "objectID": "base_data_processing.html#字符串函数",
    "href": "base_data_processing.html#字符串函数",
    "title": "\n5  基本数据处理\n",
    "section": "\n5.7 字符串函数",
    "text": "5.7 字符串函数\n\nCode# 正则表达式\nsubstr(x=\"qwertyyuio\",start = 2,stop=4)            #子串\n#&gt; [1] \"wer\"\nsub(pattern = \" \",replacement = \".\",\n    x=\"hello world\",ignore.case = FALSE,fixed = FALSE)  #查找替换\n#&gt; [1] \"hello.world\"\ngrep(pattern = \"v\",x=c(\"a\",\"v\",\"D\",\"A\",\"f\",\"J\"),ignore.case = FALSE,fixed = FALSE)   # 查找,返回下标\n#&gt; [1] 2\nstrsplit(x=\"a.fa.fag\",split = \"\\\\.\",fixed = FALSE)  # 分隔，\\\\转义字符\n#&gt; [[1]]\n#&gt; [1] \"a\"   \"fa\"  \"fag\"\n\n\n#\npaste(\"x\",c(\"a\",\"b\"),sep=\"+\")   #连接\n#&gt; [1] \"x+a\" \"x+b\"\ncat(\"hello\",\"BOb\",\"\\b\\n\",\"\\bIsn\\' R\",\"\\t\",\"GREAT?\\n\",sep = \" \" )\n#&gt; hello BOb \n#&gt;  Isn' R      GREAT?\n\n#\ntoupper(\"abc\")              #大写转换\n#&gt; [1] \"ABC\"\ntolower(\"aaAGEErg\")         #小写转换\n#&gt; [1] \"aaageerg\"",
    "crumbs": [
      "Data science",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>基本数据处理</span>"
    ]
  },
  {
    "objectID": "base_data_processing.html#apply函数簇",
    "href": "base_data_processing.html#apply函数簇",
    "title": "\n5  基本数据处理\n",
    "section": "\n5.8 apply函数簇",
    "text": "5.8 apply函数簇\n\n5.8.0.1 apply()\n\n\nCodeapply(X = mtcars, MARGIN = 2, FUN = mean)\n#&gt;        mpg        cyl       disp         hp       drat         wt       qsec \n#&gt;  20.090625   6.187500 230.721875 146.687500   3.596563   3.217250  17.848750 \n#&gt;         vs         am       gear       carb \n#&gt;   0.437500   0.406250   3.687500   2.812500\n\n\n\n5.8.0.2 aggregate()\n\n\nCodeaggregate(x = mtcars,\n          by = list(am=mtcars$am,cyl=mtcars$cyl),\n          FUN = mean)  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nam\ncyl\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n\n0\n4\n22.90000\n4\n135.8667\n84.66667\n3.770000\n2.935000\n20.97000\n1.000\n0\n3.666667\n1.666667\n\n\n1\n4\n28.07500\n4\n93.6125\n81.87500\n4.183750\n2.042250\n18.45000\n0.875\n1\n4.250000\n1.500000\n\n\n0\n6\n19.12500\n6\n204.5500\n115.25000\n3.420000\n3.388750\n19.21500\n1.000\n0\n3.500000\n2.500000\n\n\n1\n6\n20.56667\n6\n155.0000\n131.66667\n3.806667\n2.755000\n16.32667\n0.000\n1\n4.333333\n4.666667\n\n\n0\n8\n15.05000\n8\n357.6167\n194.16667\n3.120833\n4.104083\n17.14250\n0.000\n0\n3.000000\n3.083333\n\n\n1\n8\n15.40000\n8\n326.0000\n299.50000\n3.880000\n3.370000\n14.55000\n0.000\n1\n5.000000\n6.000000\n\n\n\n\n\nCodeaggregate(.~am+cyl,\n          data = mtcars,\n          FUN = mean)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nam\ncyl\nmpg\ndisp\nhp\ndrat\nwt\nqsec\nvs\ngear\ncarb\n\n\n\n0\n4\n22.90000\n135.8667\n84.66667\n3.770000\n2.935000\n20.97000\n1.000\n3.666667\n1.666667\n\n\n1\n4\n28.07500\n93.6125\n81.87500\n4.183750\n2.042250\n18.45000\n0.875\n4.250000\n1.500000\n\n\n0\n6\n19.12500\n204.5500\n115.25000\n3.420000\n3.388750\n19.21500\n1.000\n3.500000\n2.500000\n\n\n1\n6\n20.56667\n155.0000\n131.66667\n3.806667\n2.755000\n16.32667\n0.000\n4.333333\n4.666667\n\n\n0\n8\n15.05000\n357.6167\n194.16667\n3.120833\n4.104083\n17.14250\n0.000\n3.000000\n3.083333\n\n\n1\n8\n15.40000\n326.0000\n299.50000\n3.880000\n3.370000\n14.55000\n0.000\n5.000000\n6.000000\n\n\n\n\n\nCodeaggregate(mpg~am+cyl,\n          data = mtcars,\n          FUN = summary)\n\n\n\n\nam\ncyl\nmpg\n\n\n\n0\n4\n21.50000\n\n\n1\n4\n21.40000\n\n\n0\n6\n17.80000\n\n\n1\n6\n19.70000\n\n\n0\n8\n10.40000\n\n\n1\n8\n15.00000\n\n\n\n\n\n\n\n5.8.0.3 by(), tapply()\n\nby()是应用于数据框的tapply的面向对象包装器。\n\nCodeby(data = mtcars[,1:3],\n   INDICES = list(cyl=mtcars$cyl),\n   FUN = summary)\n#&gt; cyl: 4\n#&gt;       mpg             cyl         disp       \n#&gt;  Min.   :21.40   Min.   :4   Min.   : 71.10  \n#&gt;  1st Qu.:22.80   1st Qu.:4   1st Qu.: 78.85  \n#&gt;  Median :26.00   Median :4   Median :108.00  \n#&gt;  Mean   :26.66   Mean   :4   Mean   :105.14  \n#&gt;  3rd Qu.:30.40   3rd Qu.:4   3rd Qu.:120.65  \n#&gt;  Max.   :33.90   Max.   :4   Max.   :146.70  \n#&gt; ------------------------------------------------------------ \n#&gt; cyl: 6\n#&gt;       mpg             cyl         disp      \n#&gt;  Min.   :17.80   Min.   :6   Min.   :145.0  \n#&gt;  1st Qu.:18.65   1st Qu.:6   1st Qu.:160.0  \n#&gt;  Median :19.70   Median :6   Median :167.6  \n#&gt;  Mean   :19.74   Mean   :6   Mean   :183.3  \n#&gt;  3rd Qu.:21.00   3rd Qu.:6   3rd Qu.:196.3  \n#&gt;  Max.   :21.40   Max.   :6   Max.   :258.0  \n#&gt; ------------------------------------------------------------ \n#&gt; cyl: 8\n#&gt;       mpg             cyl         disp      \n#&gt;  Min.   :10.40   Min.   :8   Min.   :275.8  \n#&gt;  1st Qu.:14.40   1st Qu.:8   1st Qu.:301.8  \n#&gt;  Median :15.20   Median :8   Median :350.5  \n#&gt;  Mean   :15.10   Mean   :8   Mean   :353.1  \n#&gt;  3rd Qu.:16.25   3rd Qu.:8   3rd Qu.:390.0  \n#&gt;  Max.   :19.20   Max.   :8   Max.   :472.0\n\nby(data = mtcars[,1:3],\n   INDICES = factor(mtcars$cyl),\n   FUN = function(x) lm( disp ~ mpg, data = x))\n#&gt; factor(mtcars$cyl): 4\n#&gt; \n#&gt; Call:\n#&gt; lm(formula = disp ~ mpg, data = x)\n#&gt; \n#&gt; Coefficients:\n#&gt; (Intercept)          mpg  \n#&gt;     233.067       -4.798  \n#&gt; \n#&gt; ------------------------------------------------------------ \n#&gt; factor(mtcars$cyl): 6\n#&gt; \n#&gt; Call:\n#&gt; lm(formula = disp ~ mpg, data = x)\n#&gt; \n#&gt; Coefficients:\n#&gt; (Intercept)          mpg  \n#&gt;     125.122        2.947  \n#&gt; \n#&gt; ------------------------------------------------------------ \n#&gt; factor(mtcars$cyl): 8\n#&gt; \n#&gt; Call:\n#&gt; lm(formula = disp ~ mpg, data = x)\n#&gt; \n#&gt; Coefficients:\n#&gt; (Intercept)          mpg  \n#&gt;      560.87       -13.76\n\ntapply(X = mtcars[,1:3],\n       INDEX = list(cyl=mtcars$cyl),\n       FUN = summary)\n#&gt; $`4`\n#&gt;       mpg             cyl         disp       \n#&gt;  Min.   :21.40   Min.   :4   Min.   : 71.10  \n#&gt;  1st Qu.:22.80   1st Qu.:4   1st Qu.: 78.85  \n#&gt;  Median :26.00   Median :4   Median :108.00  \n#&gt;  Mean   :26.66   Mean   :4   Mean   :105.14  \n#&gt;  3rd Qu.:30.40   3rd Qu.:4   3rd Qu.:120.65  \n#&gt;  Max.   :33.90   Max.   :4   Max.   :146.70  \n#&gt; \n#&gt; $`6`\n#&gt;       mpg             cyl         disp      \n#&gt;  Min.   :17.80   Min.   :6   Min.   :145.0  \n#&gt;  1st Qu.:18.65   1st Qu.:6   1st Qu.:160.0  \n#&gt;  Median :19.70   Median :6   Median :167.6  \n#&gt;  Mean   :19.74   Mean   :6   Mean   :183.3  \n#&gt;  3rd Qu.:21.00   3rd Qu.:6   3rd Qu.:196.3  \n#&gt;  Max.   :21.40   Max.   :6   Max.   :258.0  \n#&gt; \n#&gt; $`8`\n#&gt;       mpg             cyl         disp      \n#&gt;  Min.   :10.40   Min.   :8   Min.   :275.8  \n#&gt;  1st Qu.:14.40   1st Qu.:8   1st Qu.:301.8  \n#&gt;  Median :15.20   Median :8   Median :350.5  \n#&gt;  Mean   :15.10   Mean   :8   Mean   :353.1  \n#&gt;  3rd Qu.:16.25   3rd Qu.:8   3rd Qu.:390.0  \n#&gt;  Max.   :19.20   Max.   :8   Max.   :472.0\n\n\n\n5.8.0.4 lapply(), sapply()\n\nlapply() returns a list of the same length as X,\nsapply() is a user-friendly version and wrapper of lapply() by default returning a vector or matrix\n\nCodex &lt;- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE,FALSE,FALSE,TRUE))\nlapply(X = x,FUN = quantile)\n#&gt; $a\n#&gt;    0%   25%   50%   75%  100% \n#&gt;  1.00  3.25  5.50  7.75 10.00 \n#&gt; \n#&gt; $beta\n#&gt;          0%         25%         50%         75%        100% \n#&gt;  0.04978707  0.25160736  1.00000000  5.05366896 20.08553692 \n#&gt; \n#&gt; $logic\n#&gt;   0%  25%  50%  75% 100% \n#&gt;  0.0  0.0  0.5  1.0  1.0\n\nsapply(x, quantile)\n#&gt;          a        beta logic\n#&gt; 0%    1.00  0.04978707   0.0\n#&gt; 25%   3.25  0.25160736   0.0\n#&gt; 50%   5.50  1.00000000   0.5\n#&gt; 75%   7.75  5.05366896   1.0\n#&gt; 100% 10.00 20.08553692   1.0\n\n\nmapply for applying a function to multiple arguments,\nrapply for a recursive version of lapply()\neapply for applying a function to each entry in an environment.",
    "crumbs": [
      "Data science",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>基本数据处理</span>"
    ]
  },
  {
    "objectID": "base_data_processing.html#概率函数",
    "href": "base_data_processing.html#概率函数",
    "title": "\n5  基本数据处理\n",
    "section": "\n5.9 概率函数",
    "text": "5.9 概率函数\n形如[dpqr]distribution_abbreviation，其中密度函数d，分布函数p，分位数函数q，随机数生成函数r\n\nCode### 正态分布\ndnorm(3,0,2)  #N(0,4)在 3 处的密度值\n#&gt; [1] 0.0647588\npnorm(1:3,0,2)#N(0,4)在1，2，3处的分布概率值\n#&gt; [1] 0.6914625 0.8413447 0.9331928\nqnorm(1-0.025,0,1)# N(0,1)的上0.025分位数\n#&gt; [1] 1.959964\nrnorm(5,3,3)  # 生成5个服从N(3,9)的随机数\n#&gt; [1]  4.4671132  6.0321270 -0.2078508  1.6965851  3.2079959\n\n\n### 二项分布\n1-sum(dbinom(0:1,400,0.02))# 命中率为0.02，独立射击400次，至少击中2次的概率\n#&gt; [1] 0.9971655\nggplot()\n\n\n\n\n\n\nCode\n\n\n### 多元正态分布\nmean&lt;-c(230.7,146.7,3.6)\nsigma&lt;-matrix(c(15360.8,6721.2,-47.1,\n                6721.2,4700.9,-16.5,\n                -47.1,16.5,0.3),nrow = 3,ncol = 3)\nlibrary(MASS)\nmulti &lt;- mvrnorm(500,mean,sigma)\nhead(multi)\n#&gt;           [,1]       [,2]     [,3]\n#&gt; [1,] 181.46426 171.934049 4.043663\n#&gt; [2,] 218.47040 162.641782 4.375564\n#&gt; [3,] 276.70353 136.277719 3.109859\n#&gt; [4,] 289.88365 128.683595 2.902872\n#&gt; [5,] 315.35691 204.021758 2.914029\n#&gt; [6,] -79.16355   4.461987 4.405606\n\n\n\n5.9.1 正态分布\n\nCodenorm &lt;- function(xlim = c(-Inf,+Inf)){\n  ggplot() + xlim(xlim) +\n    geom_function(fun = dnorm, args = list(mean = 0, sd = 1), color=\"red\")+\n        scale_y_continuous(limits = c(0,1))+\n    geom_function(fun = pnorm,color=\"blue\")\n}\nnorm(c(-5,5))\n\n\n\n\n\n\n\n\n5.9.2 二项分布\n\nCodebinom &lt;- function(n,p){\n    ggplot() +\n        geom_line(data.frame(x = 0:n, \n                      y = dbinom(0:n, size = n, prob = p)), \n           mapping=aes(x = x, y = y),\n           color=\"red\")+\n        geom_line(data.frame(x = 0:n, \n                      y = pbinom(0:n, size = n, prob = p)), \n           mapping=aes(x = x, y = y),\n           color=\"blue\")\n}\n\nbinom(10,0.5)",
    "crumbs": [
      "Data science",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>基本数据处理</span>"
    ]
  },
  {
    "objectID": "functional_programming.html",
    "href": "functional_programming.html",
    "title": "\n6  函数式编程\n",
    "section": "",
    "text": "6.1 向量式函数",
    "crumbs": [
      "Data science",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>函数式编程</span>"
    ]
  },
  {
    "objectID": "functional_programming.html#数据框式函数",
    "href": "functional_programming.html#数据框式函数",
    "title": "\n6  函数式编程\n",
    "section": "\n6.2 数据框式函数",
    "text": "6.2 数据框式函数\n\nCode\ngrouped_mean &lt;- function(df, group_var, mean_var) {\n    df |&gt; \n        group_by({{ group_var }}) |&gt; #embracing拥抱 {{}}\n        summarize(mean=mean({{ mean_var }}))   \n    #拥抱变量会告诉 dplyr使用存储在参数中的值，而不是将参数作为文本变量名称\n}\ndf &lt;- tibble(\n    mean_var = c(1,2),\n    group_var = c(\"g\",\"h\"),\n    group = c(1,1),\n    x = c(10,100),\n    y = c(100,200)\n)\ndf\n\n\n\n\nmean_var\ngroup_var\ngroup\nx\ny\n\n\n\n1\ng\n1\n10\n100\n\n\n2\nh\n1\n100\n200\n\n\n\n\n\nCodegrouped_mean(df,group, x)\n\n\n\n\ngroup\nmean\n\n\n1\n55\n\n\n\n\n\n\n6.2.1 何时使用{{}}\n\nData-masking: arrange()filter()summarize() compute with variables\nTidy-selection：select()relocate()rename() select variables\n\nCode\n# \nsummary6 &lt;- function(data, var) {\n    data |&gt; summarize(\n        min = min({{ var }}, na.rm = TRUE),\n        mean = mean({{ var }}, na.rm = TRUE),\n        median = median({{ var }}, na.rm = TRUE),\n        max = max({{ var }}, na.rm = TRUE),\n        n = n(),\n        n_miss = sum(is.na({{ var }})),\n        .groups = \"drop\"\n    )\n}\ndiamonds |&gt; \n    group_by(cut) |&gt; \n    summary6(carat)\n\n\n\n\ncut\nmin\nmean\nmedian\nmax\nn\nn_miss\n\n\n\nFair\n0.22\n1.0461366\n1.00\n5.01\n1610\n0\n\n\nGood\n0.23\n0.8491847\n0.82\n3.01\n4906\n0\n\n\nVery Good\n0.20\n0.8063814\n0.71\n4.00\n12082\n0\n\n\nPremium\n0.20\n0.8919549\n0.86\n4.01\n13791\n0\n\n\nIdeal\n0.20\n0.7028370\n0.54\n3.50\n21551\n0\n\n\n\n\n\nCode\n\n# \ncount_prop &lt;- function(df, var, sort = FALSE) {\n    df |&gt;\n        dplyr::count({{ var }}, sort = sort) |&gt;\n        mutate(prop = n / sum(n))\n}\ndiamonds |&gt; count_prop(clarity)\n\n\n\n\nclarity\nn\nprop\n\n\n\nI1\n741\n0.0137375\n\n\nSI2\n9194\n0.1704486\n\n\nSI1\n13065\n0.2422136\n\n\nVS2\n12258\n0.2272525\n\n\nVS1\n8171\n0.1514831\n\n\nVVS2\n5066\n0.0939192\n\n\nVVS1\n3655\n0.0677605\n\n\nIF\n1790\n0.0331850\n\n\n\n\n\nCode\n#\nunique_where &lt;- function(df, condition, var) {\n    df |&gt; \n        dplyr::filter({{ condition }}) |&gt; \n        distinct({{ var }}) |&gt; \n        arrange({{ var }})\n}\nmtcars|&gt; unique_where(cyl==4, mpg)\n\n\n\n\n\nmpg\n\n\n\nVolvo 142E\n21.4\n\n\nToyota Corona\n21.5\n\n\nDatsun 710\n22.8\n\n\nMerc 240D\n24.4\n\n\nPorsche 914-2\n26.0\n\n\nFiat X1-9\n27.3\n\n\nHonda Civic\n30.4\n\n\nFiat 128\n32.4\n\n\nToyota Corolla\n33.9\n\n\n\n\n\nCode\n\n# Data-masking vs. tidy-selection\ncount_missing &lt;- function(df, group_vars, x_var) {\n    df |&gt; \n        group_by({{ group_vars }}) |&gt; #select variables inside a function that uses data-masking\n        summarize(\n            n_miss = sum(is.na({{ x_var }})),\n            .groups = \"drop\"\n        )\n}\nmtcars|&gt; \n    count_missing(c(cyl,am), mpg)\n#&gt; Error in `group_by()`:\n#&gt; ℹ In argument: `c(cyl, am)`.\n#&gt; Caused by error:\n#&gt; ! `c(cyl, am)` must be size 32 or 1, not 64.\n\ncount_missing &lt;- function(df, group_vars, x_var) {\n    df |&gt;      #pick()\n        group_by(pick({{ group_vars }})) |&gt; #use tidy-selection inside data-masking functions\n        summarize(                          \n            n_miss = sum(is.na({{ x_var }})),\n            .groups = \"drop\"\n        )\n}\n\nmtcars|&gt; \n    count_missing(c(cyl,am), mpg)\n\n\n\n\ncyl\nam\nn_miss\n\n\n\n4\n0\n0\n\n\n4\n1\n0\n\n\n6\n0\n0\n\n\n6\n1\n0\n\n\n8\n0\n0\n\n\n8\n1\n0",
    "crumbs": [
      "Data science",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>函数式编程</span>"
    ]
  },
  {
    "objectID": "functional_programming.html#图形函数",
    "href": "functional_programming.html#图形函数",
    "title": "\n6  函数式编程\n",
    "section": "\n6.3 图形函数",
    "text": "6.3 图形函数\n\nCodehistogram &lt;- function(df, var, binwidth = NULL) {\n    df |&gt; \n        ggplot(aes(x = {{ var }})) + \n        geom_histogram(binwidth = binwidth)\n}\n\ndiamonds |&gt; histogram(carat, 0.1)\n\n\n\n\n\n\nCode\nsorted_bars &lt;- function(df, var) {\n    df |&gt;               # walrus operator   :=\n        mutate({{ var }} := fct_rev(fct_infreq({{ var }})))  |&gt;\n        ggplot(aes(y = {{ var }})) +\n        geom_bar()\n}\n\ndiamonds |&gt; sorted_bars(clarity)\n\n\n\n\n\n\n\n\n\n\n\n\n:::{#quarto-navigation-envelope .hidden}\n[R data science]{.hidden render-id=\"quarto-int-sidebar-title\"}\n[R data science]{.hidden render-id=\"quarto-int-navbar-title\"}\n[&lt;span class='chapter-number'&gt;5&lt;/span&gt;  &lt;span class='chapter-title'&gt;基本数据处理&lt;/span&gt;]{.hidden render-id=\"quarto-int-prev\"}\n[参考资料]{.hidden render-id=\"quarto-int-sidebar:/index.html参考资料\"}\n[Programming]{.hidden render-id=\"quarto-int-sidebar:quarto-sidebar-section-1\"}\n[&lt;span class='chapter-number'&gt;1&lt;/span&gt;  &lt;span class='chapter-title'&gt;数据类型和数据结构&lt;/span&gt;]{.hidden render-id=\"quarto-int-sidebar:/basic_data_type_class.html&lt;span-class='chapter-number'&gt;1&lt;/span&gt;--&lt;span-class='chapter-title'&gt;数据类型和数据结构&lt;/span&gt;\"}\n[&lt;span class='chapter-number'&gt;2&lt;/span&gt;  &lt;span class='chapter-title'&gt;函数&lt;/span&gt;]{.hidden render-id=\"quarto-int-sidebar:/function.html&lt;span-class='chapter-number'&gt;2&lt;/span&gt;--&lt;span-class='chapter-title'&gt;函数&lt;/span&gt;\"}\n[&lt;span class='chapter-number'&gt;3&lt;/span&gt;  &lt;span class='chapter-title'&gt;高效&lt;/span&gt;]{.hidden render-id=\"quarto-int-sidebar:/efficient.html&lt;span-class='chapter-number'&gt;3&lt;/span&gt;--&lt;span-class='chapter-title'&gt;高效&lt;/span&gt;\"}\n[Data science]{.hidden render-id=\"quarto-int-sidebar:quarto-sidebar-section-2\"}\n[&lt;span class='chapter-number'&gt;4&lt;/span&gt;  &lt;span class='chapter-title'&gt;读入和写出&lt;/span&gt;]{.hidden render-id=\"quarto-int-sidebar:/I-O.html&lt;span-class='chapter-number'&gt;4&lt;/span&gt;--&lt;span-class='chapter-title'&gt;读入和写出&lt;/span&gt;\"}\n[&lt;span class='chapter-number'&gt;5&lt;/span&gt;  &lt;span class='chapter-title'&gt;基本数据处理&lt;/span&gt;]{.hidden render-id=\"quarto-int-sidebar:/base_data_processing.html&lt;span-class='chapter-number'&gt;5&lt;/span&gt;--&lt;span-class='chapter-title'&gt;基本数据处理&lt;/span&gt;\"}\n[&lt;span class='chapter-number'&gt;6&lt;/span&gt;  &lt;span class='chapter-title'&gt;函数式编程&lt;/span&gt;]{.hidden render-id=\"quarto-int-sidebar:/functional_programming.html&lt;span-class='chapter-number'&gt;6&lt;/span&gt;--&lt;span-class='chapter-title'&gt;函数式编程&lt;/span&gt;\"}\n[Data science]{.hidden render-id=\"quarto-breadcrumbs-Data-science\"}\n[&lt;span class='chapter-number'&gt;6&lt;/span&gt;  &lt;span class='chapter-title'&gt;函数式编程&lt;/span&gt;]{.hidden render-id=\"quarto-breadcrumbs-&lt;span-class='chapter-number'&gt;6&lt;/span&gt;--&lt;span-class='chapter-title'&gt;函数式编程&lt;/span&gt;\"}\n:::\n\n\n\n:::{#quarto-meta-markdown .hidden}\n[R data science - [6]{.chapter-number}  [函数式编程]{.chapter-title}]{.hidden render-id=\"quarto-metatitle\"}\n[R data science - [6]{.chapter-number}  [函数式编程]{.chapter-title}]{.hidden render-id=\"quarto-twittercardtitle\"}\n[R data science - [6]{.chapter-number}  [函数式编程]{.chapter-title}]{.hidden render-id=\"quarto-ogcardtitle\"}\n[R data science]{.hidden render-id=\"quarto-metasitename\"}\n[]{.hidden render-id=\"quarto-twittercarddesc\"}\n[]{.hidden render-id=\"quarto-ogcardddesc\"}\n:::\n\n\n\n\n&lt;!-- --&gt;\n\n::: {.quarto-embedded-source-code}\n```````````````````{.markdown shortcodes=\"false\"}\n# 函数式编程\n\n## 向量式函数\n\n\n## 数据框式函数\n\nquarto-executable-code-5450563D\n\n```r\ngrouped_mean &lt;- function(df, group_var, mean_var) {\n    df |&gt; \n        group_by({{ group_var }}) |&gt; #embracing拥抱 {{}}\n        summarize(mean=mean({{ mean_var }}))   \n    #拥抱变量会告诉 dplyr使用存储在参数中的值，而不是将参数作为文本变量名称\n}\ndf &lt;- tibble(\n    mean_var = c(1,2),\n    group_var = c(\"g\",\"h\"),\n    group = c(1,1),\n    x = c(10,100),\n    y = c(100,200)\n)\ndf\ngrouped_mean(df,group, x)\n\n6.3.1 何时使用{{}}\n\nData-masking: arrange()filter()summarize() compute with variables\nTidy-selection：select()relocate()rename() select variables\nquarto-executable-code-5450563D\n# \nsummary6 &lt;- function(data, var) {\n    data |&gt; summarize(\n        min = min({{ var }}, na.rm = TRUE),\n        mean = mean({{ var }}, na.rm = TRUE),\n        median = median({{ var }}, na.rm = TRUE),\n        max = max({{ var }}, na.rm = TRUE),\n        n = n(),\n        n_miss = sum(is.na({{ var }})),\n        .groups = \"drop\"\n    )\n}\ndiamonds |&gt; \n    group_by(cut) |&gt; \n    summary6(carat)\n\n\n# \ncount_prop &lt;- function(df, var, sort = FALSE) {\n    df |&gt;\n        dplyr::count({{ var }}, sort = sort) |&gt;\n        mutate(prop = n / sum(n))\n}\ndiamonds |&gt; count_prop(clarity)\n\n#\nunique_where &lt;- function(df, condition, var) {\n    df |&gt; \n        dplyr::filter({{ condition }}) |&gt; \n        distinct({{ var }}) |&gt; \n        arrange({{ var }})\n}\nmtcars|&gt; unique_where(cyl==4, mpg)\n\n\n# Data-masking vs. tidy-selection\ncount_missing &lt;- function(df, group_vars, x_var) {\n    df |&gt; \n        group_by({{ group_vars }}) |&gt; #select variables inside a function that uses data-masking\n        summarize(\n            n_miss = sum(is.na({{ x_var }})),\n            .groups = \"drop\"\n        )\n}\nmtcars|&gt; \n    count_missing(c(cyl,am), mpg)\n\ncount_missing &lt;- function(df, group_vars, x_var) {\n    df |&gt;      #pick()\n        group_by(pick({{ group_vars }})) |&gt; #use tidy-selection inside data-masking functions\n        summarize(                          \n            n_miss = sum(is.na({{ x_var }})),\n            .groups = \"drop\"\n        )\n}\n\nmtcars|&gt; \n    count_missing(c(cyl,am), mpg)",
    "crumbs": [
      "Data science",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>函数式编程</span>"
    ]
  },
  {
    "objectID": "functional_programming.html#图形函数-1",
    "href": "functional_programming.html#图形函数-1",
    "title": "\n6  函数式编程\n",
    "section": "\n6.4 图形函数",
    "text": "6.4 图形函数\nquarto-executable-code-5450563D\nhistogram &lt;- function(df, var, binwidth = NULL) {\n    df |&gt; \n        ggplot(aes(x = {{ var }})) + \n        geom_histogram(binwidth = binwidth)\n}\n\ndiamonds |&gt; histogram(carat, 0.1)\n\nsorted_bars &lt;- function(df, var) {\n    df |&gt;               # walrus operator   :=\n        mutate({{ var }} := fct_rev(fct_infreq({{ var }})))  |&gt;\n        ggplot(aes(y = {{ var }})) +\n        geom_bar()\n}\n\ndiamonds |&gt; sorted_bars(clarity)\n\n:::",
    "crumbs": [
      "Data science",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>函数式编程</span>"
    ]
  }
]