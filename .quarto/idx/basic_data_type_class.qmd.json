{"title":"数据类型和数据结构","markdown":{"yaml":{"title":"数据类型和数据结构"},"headingText":"数据类型","headingAttr":{"id":"","classes":[],"keyvalue":[["style","color:red"]]},"containsRefs":false,"markdown":"\n\n\n强制类型转换：字符 \\> 双精度 \\> 整数 \\> 逻辑\n\n### numeric -- 数值型\n\n```{r}\nc(c(1.5, 2), c(3L, 4))\n```\n\n#### double -- 双精度\n\n十进制`decimal ()`，科学计数法`scientific ()` ，十六进制`hexadecimal ()`\n\n```{r}\n0.1234\n1.23e4\n0x111   # 16^2×1+ 16^1×1 + 16^0×1\n```\n\n浮点标准定义的特殊值\n\n-   无穷大\n-   Not a Number\n\n```{r}\nInf\n-Inf\nNaN\n0/0\nis.nan(0/0)\n```\n\n#### integer --整型\n\n```{r}\nclass(128L)\n```\n\n### character -- 字符型\n\n```{r}\ntypeof(c(\"c\"))\nclass(\"car\")\n```\n\n### logical -- 逻辑型\n\n```{r}\ntypeof(c(T,FALSE))\nclass(c(TRUE,FALSE))\n```\n\n### complex型\n\n```{r}\n\ntypeof(c(1+2i,3-4i)) \nclass(c(1+2i,3-4i))\n```\n\n### raw型\n\n```{r}\ncharToRaw(\"abcde12345\") #字符串中每个字符的原始存储格式（十六进制？）\ntypeof(charToRaw(\"abcde12345\")) \nclass(charToRaw(\"abcde12345\"))\n```\n\n### NA -- 缺失值\n\n从技术上讲，每种原子类型有一个缺失值：NA_logical、NA_integer、NA_double、NA_character。\n\nNot Available\n\n```{r}\nNA\nis.na(NA)\nanyNA(c(1,3,NA,9))\nx<-c(2,3,1,4,5,NA,NA)\nna.omit(x)\n```\n\n## 数据结构 {style=\"color:red\"}\n\n**class**：是一种基于***面向对象编程***的R的抽象类型划分，或者理解为一种数据结构。\n\n### atomic vectors\n\n向量,同一类元素的集合。 `c()  Combine Values into a Vector or List`\n\n![](images/summary-tree-atomic.png){fig-align=\"center\" width=\"50%\"}\n\n还有不常用的complex 和 raw。\n\n| 每一种原子向量都有一种特殊的语法来创建单元素向量，也就是标量**scalar**。\n\n```{r}\n#单元素向量\n1 == c(1)\nis.vector(1)\n  \n\"a\"\nis.vector(\"a\")\n\n#使用函数c()创建向量\n\nc(1)\nc(1,2,3,4,5)\nc(\"a\",\"b\",\"c\")\nc(list(1),list(T)) |> is.vector()\n```\n\n列表不存储值本身，而是存储对它们的引用：\n\n```{r}\nl1 <- list(1,2,3)\n```\n\n![](images/list.png){#fig-list fig-align=\"center\" width=\"50%\"}\n\n#### 属性\n\n```{r}\na <- 1:3\nattr(a, \"x\") <- \"abcdef\"\nattr(a, \"x\")\nattr(a, \"y\") <- 4:6\nstr(attributes(a))\n\n# 或者\na <- structure(\n  1:3, \n  x = \"abcdef\",\n  y = 4:6\n)\nstr(attributes(a))\n```\n\n大多数操作都会丢失大多数属性。\n\n只有两个属性是例行保留的：\n\n1.  names，一个字符向量，为每个元素命名。\n\n    ```{r}\n    # When creating it: \n    x <- c(a = 1, b = 2, c = 3)\n    attributes(x)\n    names(x)\n\n    # By assigning a character vector to names()\n    x <- 1:3\n    names(x) <- c(\"a\", \"b\", \"c\")\n\n    # Inline, with setNames():\n    x <- setNames(1:3, c(\"a\", \"b\", \"c\"))\n    ```\n\n2.  dim，dimensions 的缩写，整数向量，用于将向量转换为矩阵或数组。\n\n    对于原子向量，dimension 属性通常用于创建矩阵或数组。对于列表，dimension 属性可用于创建列表矩阵或列表数组：\n\n    ```{r}\n    z <- 1:6\n    dim(z) <- c(3, 2, 1)\n    z\n    attributes(z)\n    dim(z)\n\n    l <- list(1:3, \"a\", TRUE, 1.0)\n    dim(l) <- c(2, 2)\n    l\n    l[[1,2]]\n    ```\n\n    | 向量            | 矩阵                  | 数组           |\n    |-----------------|-----------------------|----------------|\n    | names()         | rownames(),colnames() | dimnames()     |\n    | length()        | nrow(),ncol()         | dim()          |\n    | c()             | rbind(),cbind()       | abind::abind() |\n    | ---             | t()                   | aperm()        |\n    | is.null(dim(x)) | is.matrix()           | is.array()     |\n\n要保留其他属性，需要创建S3 类。\n\n### S3原子向量\n\nbase R 中使用的四个重要的 S3 向量：\n\n1.  分类数据，其中值来自**factor**向量中记录的一组固定水平。\n\n2.  日期（具有日期分辨率），记录在**Date**向量中。\n\n3.  日期时间（具有秒或亚秒分辨率），存储在 **POSIXct** 向量中。\n\n4.  持续时间，存储在**difftime**向量中。\n\n![](images/summary-tree-s3-baseR.png){fig-align=\"center\" width=\"50%\"}\n\n#### factor\n\n因子，分类变量，建立在具有两个属性（class，levels）的 **integer 向量**之上。\n\n`factor(vector,ordered=FALSE,levels=c(v1,v2,…),labels= ,...)` ，在内存中以整数向量`c(1,2,3,...,k)`存储。\n\n```{r}\n# 存储形式\nx <- factor(c(\"a\", \"b\", \"b\", \"a\"))\nx\ntypeof(x)\nattributes(x)\nlevels(x)\nclass(x)\n\n\n# 名义变量 nominal variable\ndiabetes<-c(\"t1\",\"t2\",\"t1\",\"t1\") \nattributes(diabetes)\ndiabetes<-factor(diabetes)\nattributes(diabetes)\n\n\n# 顺序变量 ordinal variable     默认水平根据字母顺序而定\nstatus<-c(\"poor\",\"better\",\"best\",\"poor\")\nstatus<-factor(status,ordered = TRUE) \nstr(status) \nstatus<-factor(status,ordered =TRUE,levels = c(\"poor\",\"better\",\"best\")) \nstr(status) \n\n\n#改变外在标签\nsex<-c(1,2,2,1)\nsex\nsex<-factor(sex,levels=c(1,2),labels = c(\"男\",\"女\")) \nstr(sex) \nsex\n\nleadership <- read_csv(\"data/leadership.txt\") |> column_to_rownames(var = \"id\")\n# 连续型变量→因子\nleadership$agecat<-cut(leadership$age,\n                    breaks = c(0,18,45,65,Inf),\n                    labels=c(\"minor\",\"young\",\"middle_age\",\"elder\"),\n                    include.lowest = TRUE,\n                    right = TRUE\n                    )\nleadership$agecat\n```\n\n#### Date\n\n日期向量建立在 **double 向量**之上，具有`class \"Date\"`属性。\n\n日期 默认格式：`\"%Y-%m-%d\" xxxx-xx-xx,例如：2023-03-15`\n\n```{r}\ntoday <- Sys.Date()\ntoday\ntypeof(today)\nattributes(today)\nclass(today)\n\nas.Date(c(\"02 14-2002\",\"01 04-2013\"),\"%m %d-%Y\") #以\"%m %d-%Y\"格式读入\nformat(Sys.Date(),\"%Y/%m/%d\") #以\"%Y/%m/%d\"格式输出\n\n\n# 双精度值（通过剥离类来查看）表示自 1970 年 1 月 1 日以来的天数\ndate <- as.Date(\"1970-02-01\")\nunclass(date)\n```\n\n#### Datetime\n\nPOSIXct 和 POSIXlt\n\n\"POSIX\"是可移植操作系统接口（ Portable Operating System Interface）的缩写，这是一个跨平台标准系列。\"ct\"代表calendar time（C 中的类型），\"lt\"代表local time（C 中的类型）。\n\nPOSIXct 向量建立在 **double 向量**之上，其中值表示自 1970-01-01 以来的秒数\n\n```{r}\nnow_ct <- as.POSIXct(\"2024-04-20 15:45\", tz = \"Asia/Shanghai\")\nnow_ct\ntypeof(now_ct)\nattributes(now_ct)\nclass(now_ct)\n\n\n```\n\n#### Durations\n\n持续时间（表示日期对或日期时间对之间的时间量）存储在difftimes中。Difftimes 建立在 **double** 之上，并且具有确定整数应如何解释的属性。\n\n```{r}\nunits_1 <- as.difftime(1, units = \"weeks\")  #units = c(\"auto\", \"secs\", \"mins\", \"hours\",\"days\", \"weeks\"))\n\nunits_1\ntypeof(units_1)\nattributes(units_1)\nclass(units_1)\nunits(units_1)\nunits(units_1) <- \"days\"\n\nattributes(units_1)\n```\n\n### matrix\n\n矩阵，所有元素必须是同一类型。\n\n`matrix(data= ,nrow=1  ,ncol=1  ,byrow=FALSE ,dimnames=list(rnames,cnames) ,...)`\n\n```{r}\nnum<-c(16,22,24,28)\nrnames<-c(\"R1\",\"R2\")\ncnames<-c(\"C1\",\"C2\")\nm<-matrix(num,nrow=2,ncol=2,byrow=TRUE,dimnames=list(rnames,cnames))\nm\n\nattributes(m)\ndim(m)\nrownames(m)\ncolnames(m)\n```\n\n### array\n\n数组，所有元素必须是同一类型。\n\n`array(data,dim_numeric_vector=c(...),dimnames = list(dim1,dim2,...),...)`\n\n```{r}\nv<-1:24 \ndim1<-c(\"A1\",\"A2\",\"A3\") \ndim2<-c(\"B1\",\"B2\",\"B3\",\"B4\")\ndim3<-c(\"C1\",\"C2\") \narray_3d<-array(v,c(3,4,2),dimnames = list(dim1,dim2,dim3)) \narray_3d\nattributes(array_3d)\ndimnames(array_3d)\n```\n\n### list\n\n从技术上讲，列表的每个元素实际上是相同的类型，因为每个元素实际上是对另一个对象的引用 @fig-list ，该对象可以是任何类型。\n\n列表，`list(name1=object1,name2=object2,...)`\n\n```{r}\nmylist<-list(title=\"My list\",\n             matr=matrix(c(\"a1\",\"b1\",\"a2\",\"b2\"),nrow=2,ncol=2,byrow=TRUE,\n                           dimnames = list(c(\"X1\",\"X2\"),c(\"Y1\",\"Y2\"))\n                         ),\n             df=data.frame(id=matrix(c(\"Lisa\",\"BOb\",\"John\",\"Jule\"),\n                                     nrow=4,ncol=1,byrow=TRUE\n                                     ),\n                           int=c(3,5,7,9),\n                           TF=c(T,T,T,F)\n                           ),\n             list=list(a=c(1,2,3),b=c(\"A\",\"B\"))\n             )\nmylist\ntypeof(mylist)\nattributes(mylist)\nclass(mylist)\nnames(mylist)\n\n```\n\n### data frame/tibble\n\n建立在`\"list\"`之上的两个最重要的 S3 向量是数据框和 tibble\n\n![](images/summary-tree-s3-df_tbl.png){fig-align=\"center\" width=\"30%\"}\n\n数据框是列向量具有 names，row.names ，class\"data.frame\" 属性的命名列表。\n\n与常规列表相比，数据框每个向量的长度必须相同。这为数据框提供了矩形结构，并解释了为什么它们共享矩阵和列表的属性\n\n```{r}\nid<-c(001231,001241,001413,001244) \nage<-c(21,14,52,15) \ndiabetes<-c(\"t1\",\"t2\",\"t1\",\"t1\") \nstatus<-c(\"poor\",\"better\",\"best\",\"poor\") \ndf1<-data.frame(patientID=id,age,diabetes,status,row.names = c(1,2,3,4),\n                stringsAsFactors = FALSE) # 4个列向量组成数据框 \ndf1\ntypeof(df1)\nattributes(df1)\nclass(df1)\nnames(df1)\ncolnames(df1)\nrow.names(df1)\nrownames(df1)\n\n```\n\n`tibblle`与`data frame`共享相同的结构。区别是`class`属性更多,不会自动进行强制类型转换，不会自动转换非法名称（自动反引号非法名称）， tibbles 只能循环较短的长度为 1 的向量，允许引用在构造过程中创建的变量。\n\n```{r}\nlibrary(tibble)\ndf2 <- tibble(x = 1:3, y = letters[1:3])\ntypeof(df2)\nattributes(df2)\n\n\nnames(tibble(`1` = 1))\n\ntibble(x = 1:4, y = 1)\n#tibble(x = 1:4, y = 1:2)\n#> Error in `tibble()`:\n#> ! Tibble columns must have compatible sizes.\n#> • Size 4: Existing data.\n#> • Size 2: Column `y`.\n#> ℹ Only values of size one are recycled.\ntibble(\n  x = 1:3,\n  y = x * 2\n)\n```\n\n#### 行名→列\n\n```{r}\ndf3 <- data.frame(\n  age = c(35, 27, 18),\n  hair = c(\"blond\", \"brown\", \"black\"),\n  row.names = c(\"Bob\", \"Susan\", \"Sam\")\n)\ndf3 |> rownames_to_column(var = \"name\")\nas_tibble(df3, rownames = \"name\")\n\n\nis_tibble(df2)\nis_tibble(df3)\nas_tibble(df3)\n```\n\n#### 列表列\n\n```{r}\ndf <- data.frame(x = 1:3)\ndf$y <- list(1:2, 1:3, 1:4)\n\ndata.frame(\n  x = 1:3, \n  y = I(list(1:2, 1:3, 1:4))\n)\n\ntibble(\n  x = 1:3, \n  y = list(1:2, 1:3, 1:4)\n)\n```\n\n### 矩阵和数据框列\n\n行数必须相等\n\n```{r}\ndfm <- data.frame(\n  x = 1:3 * 10\n)\ndfm$y <- matrix(1:9, nrow = 3)\ndfm$z <- data.frame(a = 3:1, b = letters[1:3], stringsAsFactors = FALSE)\ndfm[1, ]\n```\n\n## `NULL`\n\n长度始终为零，并且没有属性。\n\n```{r}\ntypeof(NULL)\nlength(NULL)\nis.null(NULL)\nc()\n```\n","srcMarkdownNoYaml":"\n\n## 数据类型 {style=\"color:red\"}\n\n强制类型转换：字符 \\> 双精度 \\> 整数 \\> 逻辑\n\n### numeric -- 数值型\n\n```{r}\nc(c(1.5, 2), c(3L, 4))\n```\n\n#### double -- 双精度\n\n十进制`decimal ()`，科学计数法`scientific ()` ，十六进制`hexadecimal ()`\n\n```{r}\n0.1234\n1.23e4\n0x111   # 16^2×1+ 16^1×1 + 16^0×1\n```\n\n浮点标准定义的特殊值\n\n-   无穷大\n-   Not a Number\n\n```{r}\nInf\n-Inf\nNaN\n0/0\nis.nan(0/0)\n```\n\n#### integer --整型\n\n```{r}\nclass(128L)\n```\n\n### character -- 字符型\n\n```{r}\ntypeof(c(\"c\"))\nclass(\"car\")\n```\n\n### logical -- 逻辑型\n\n```{r}\ntypeof(c(T,FALSE))\nclass(c(TRUE,FALSE))\n```\n\n### complex型\n\n```{r}\n\ntypeof(c(1+2i,3-4i)) \nclass(c(1+2i,3-4i))\n```\n\n### raw型\n\n```{r}\ncharToRaw(\"abcde12345\") #字符串中每个字符的原始存储格式（十六进制？）\ntypeof(charToRaw(\"abcde12345\")) \nclass(charToRaw(\"abcde12345\"))\n```\n\n### NA -- 缺失值\n\n从技术上讲，每种原子类型有一个缺失值：NA_logical、NA_integer、NA_double、NA_character。\n\nNot Available\n\n```{r}\nNA\nis.na(NA)\nanyNA(c(1,3,NA,9))\nx<-c(2,3,1,4,5,NA,NA)\nna.omit(x)\n```\n\n## 数据结构 {style=\"color:red\"}\n\n**class**：是一种基于***面向对象编程***的R的抽象类型划分，或者理解为一种数据结构。\n\n### atomic vectors\n\n向量,同一类元素的集合。 `c()  Combine Values into a Vector or List`\n\n![](images/summary-tree-atomic.png){fig-align=\"center\" width=\"50%\"}\n\n还有不常用的complex 和 raw。\n\n| 每一种原子向量都有一种特殊的语法来创建单元素向量，也就是标量**scalar**。\n\n```{r}\n#单元素向量\n1 == c(1)\nis.vector(1)\n  \n\"a\"\nis.vector(\"a\")\n\n#使用函数c()创建向量\n\nc(1)\nc(1,2,3,4,5)\nc(\"a\",\"b\",\"c\")\nc(list(1),list(T)) |> is.vector()\n```\n\n列表不存储值本身，而是存储对它们的引用：\n\n```{r}\nl1 <- list(1,2,3)\n```\n\n![](images/list.png){#fig-list fig-align=\"center\" width=\"50%\"}\n\n#### 属性\n\n```{r}\na <- 1:3\nattr(a, \"x\") <- \"abcdef\"\nattr(a, \"x\")\nattr(a, \"y\") <- 4:6\nstr(attributes(a))\n\n# 或者\na <- structure(\n  1:3, \n  x = \"abcdef\",\n  y = 4:6\n)\nstr(attributes(a))\n```\n\n大多数操作都会丢失大多数属性。\n\n只有两个属性是例行保留的：\n\n1.  names，一个字符向量，为每个元素命名。\n\n    ```{r}\n    # When creating it: \n    x <- c(a = 1, b = 2, c = 3)\n    attributes(x)\n    names(x)\n\n    # By assigning a character vector to names()\n    x <- 1:3\n    names(x) <- c(\"a\", \"b\", \"c\")\n\n    # Inline, with setNames():\n    x <- setNames(1:3, c(\"a\", \"b\", \"c\"))\n    ```\n\n2.  dim，dimensions 的缩写，整数向量，用于将向量转换为矩阵或数组。\n\n    对于原子向量，dimension 属性通常用于创建矩阵或数组。对于列表，dimension 属性可用于创建列表矩阵或列表数组：\n\n    ```{r}\n    z <- 1:6\n    dim(z) <- c(3, 2, 1)\n    z\n    attributes(z)\n    dim(z)\n\n    l <- list(1:3, \"a\", TRUE, 1.0)\n    dim(l) <- c(2, 2)\n    l\n    l[[1,2]]\n    ```\n\n    | 向量            | 矩阵                  | 数组           |\n    |-----------------|-----------------------|----------------|\n    | names()         | rownames(),colnames() | dimnames()     |\n    | length()        | nrow(),ncol()         | dim()          |\n    | c()             | rbind(),cbind()       | abind::abind() |\n    | ---             | t()                   | aperm()        |\n    | is.null(dim(x)) | is.matrix()           | is.array()     |\n\n要保留其他属性，需要创建S3 类。\n\n### S3原子向量\n\nbase R 中使用的四个重要的 S3 向量：\n\n1.  分类数据，其中值来自**factor**向量中记录的一组固定水平。\n\n2.  日期（具有日期分辨率），记录在**Date**向量中。\n\n3.  日期时间（具有秒或亚秒分辨率），存储在 **POSIXct** 向量中。\n\n4.  持续时间，存储在**difftime**向量中。\n\n![](images/summary-tree-s3-baseR.png){fig-align=\"center\" width=\"50%\"}\n\n#### factor\n\n因子，分类变量，建立在具有两个属性（class，levels）的 **integer 向量**之上。\n\n`factor(vector,ordered=FALSE,levels=c(v1,v2,…),labels= ,...)` ，在内存中以整数向量`c(1,2,3,...,k)`存储。\n\n```{r}\n# 存储形式\nx <- factor(c(\"a\", \"b\", \"b\", \"a\"))\nx\ntypeof(x)\nattributes(x)\nlevels(x)\nclass(x)\n\n\n# 名义变量 nominal variable\ndiabetes<-c(\"t1\",\"t2\",\"t1\",\"t1\") \nattributes(diabetes)\ndiabetes<-factor(diabetes)\nattributes(diabetes)\n\n\n# 顺序变量 ordinal variable     默认水平根据字母顺序而定\nstatus<-c(\"poor\",\"better\",\"best\",\"poor\")\nstatus<-factor(status,ordered = TRUE) \nstr(status) \nstatus<-factor(status,ordered =TRUE,levels = c(\"poor\",\"better\",\"best\")) \nstr(status) \n\n\n#改变外在标签\nsex<-c(1,2,2,1)\nsex\nsex<-factor(sex,levels=c(1,2),labels = c(\"男\",\"女\")) \nstr(sex) \nsex\n\nleadership <- read_csv(\"data/leadership.txt\") |> column_to_rownames(var = \"id\")\n# 连续型变量→因子\nleadership$agecat<-cut(leadership$age,\n                    breaks = c(0,18,45,65,Inf),\n                    labels=c(\"minor\",\"young\",\"middle_age\",\"elder\"),\n                    include.lowest = TRUE,\n                    right = TRUE\n                    )\nleadership$agecat\n```\n\n#### Date\n\n日期向量建立在 **double 向量**之上，具有`class \"Date\"`属性。\n\n日期 默认格式：`\"%Y-%m-%d\" xxxx-xx-xx,例如：2023-03-15`\n\n```{r}\ntoday <- Sys.Date()\ntoday\ntypeof(today)\nattributes(today)\nclass(today)\n\nas.Date(c(\"02 14-2002\",\"01 04-2013\"),\"%m %d-%Y\") #以\"%m %d-%Y\"格式读入\nformat(Sys.Date(),\"%Y/%m/%d\") #以\"%Y/%m/%d\"格式输出\n\n\n# 双精度值（通过剥离类来查看）表示自 1970 年 1 月 1 日以来的天数\ndate <- as.Date(\"1970-02-01\")\nunclass(date)\n```\n\n#### Datetime\n\nPOSIXct 和 POSIXlt\n\n\"POSIX\"是可移植操作系统接口（ Portable Operating System Interface）的缩写，这是一个跨平台标准系列。\"ct\"代表calendar time（C 中的类型），\"lt\"代表local time（C 中的类型）。\n\nPOSIXct 向量建立在 **double 向量**之上，其中值表示自 1970-01-01 以来的秒数\n\n```{r}\nnow_ct <- as.POSIXct(\"2024-04-20 15:45\", tz = \"Asia/Shanghai\")\nnow_ct\ntypeof(now_ct)\nattributes(now_ct)\nclass(now_ct)\n\n\n```\n\n#### Durations\n\n持续时间（表示日期对或日期时间对之间的时间量）存储在difftimes中。Difftimes 建立在 **double** 之上，并且具有确定整数应如何解释的属性。\n\n```{r}\nunits_1 <- as.difftime(1, units = \"weeks\")  #units = c(\"auto\", \"secs\", \"mins\", \"hours\",\"days\", \"weeks\"))\n\nunits_1\ntypeof(units_1)\nattributes(units_1)\nclass(units_1)\nunits(units_1)\nunits(units_1) <- \"days\"\n\nattributes(units_1)\n```\n\n### matrix\n\n矩阵，所有元素必须是同一类型。\n\n`matrix(data= ,nrow=1  ,ncol=1  ,byrow=FALSE ,dimnames=list(rnames,cnames) ,...)`\n\n```{r}\nnum<-c(16,22,24,28)\nrnames<-c(\"R1\",\"R2\")\ncnames<-c(\"C1\",\"C2\")\nm<-matrix(num,nrow=2,ncol=2,byrow=TRUE,dimnames=list(rnames,cnames))\nm\n\nattributes(m)\ndim(m)\nrownames(m)\ncolnames(m)\n```\n\n### array\n\n数组，所有元素必须是同一类型。\n\n`array(data,dim_numeric_vector=c(...),dimnames = list(dim1,dim2,...),...)`\n\n```{r}\nv<-1:24 \ndim1<-c(\"A1\",\"A2\",\"A3\") \ndim2<-c(\"B1\",\"B2\",\"B3\",\"B4\")\ndim3<-c(\"C1\",\"C2\") \narray_3d<-array(v,c(3,4,2),dimnames = list(dim1,dim2,dim3)) \narray_3d\nattributes(array_3d)\ndimnames(array_3d)\n```\n\n### list\n\n从技术上讲，列表的每个元素实际上是相同的类型，因为每个元素实际上是对另一个对象的引用 @fig-list ，该对象可以是任何类型。\n\n列表，`list(name1=object1,name2=object2,...)`\n\n```{r}\nmylist<-list(title=\"My list\",\n             matr=matrix(c(\"a1\",\"b1\",\"a2\",\"b2\"),nrow=2,ncol=2,byrow=TRUE,\n                           dimnames = list(c(\"X1\",\"X2\"),c(\"Y1\",\"Y2\"))\n                         ),\n             df=data.frame(id=matrix(c(\"Lisa\",\"BOb\",\"John\",\"Jule\"),\n                                     nrow=4,ncol=1,byrow=TRUE\n                                     ),\n                           int=c(3,5,7,9),\n                           TF=c(T,T,T,F)\n                           ),\n             list=list(a=c(1,2,3),b=c(\"A\",\"B\"))\n             )\nmylist\ntypeof(mylist)\nattributes(mylist)\nclass(mylist)\nnames(mylist)\n\n```\n\n### data frame/tibble\n\n建立在`\"list\"`之上的两个最重要的 S3 向量是数据框和 tibble\n\n![](images/summary-tree-s3-df_tbl.png){fig-align=\"center\" width=\"30%\"}\n\n数据框是列向量具有 names，row.names ，class\"data.frame\" 属性的命名列表。\n\n与常规列表相比，数据框每个向量的长度必须相同。这为数据框提供了矩形结构，并解释了为什么它们共享矩阵和列表的属性\n\n```{r}\nid<-c(001231,001241,001413,001244) \nage<-c(21,14,52,15) \ndiabetes<-c(\"t1\",\"t2\",\"t1\",\"t1\") \nstatus<-c(\"poor\",\"better\",\"best\",\"poor\") \ndf1<-data.frame(patientID=id,age,diabetes,status,row.names = c(1,2,3,4),\n                stringsAsFactors = FALSE) # 4个列向量组成数据框 \ndf1\ntypeof(df1)\nattributes(df1)\nclass(df1)\nnames(df1)\ncolnames(df1)\nrow.names(df1)\nrownames(df1)\n\n```\n\n`tibblle`与`data frame`共享相同的结构。区别是`class`属性更多,不会自动进行强制类型转换，不会自动转换非法名称（自动反引号非法名称）， tibbles 只能循环较短的长度为 1 的向量，允许引用在构造过程中创建的变量。\n\n```{r}\nlibrary(tibble)\ndf2 <- tibble(x = 1:3, y = letters[1:3])\ntypeof(df2)\nattributes(df2)\n\n\nnames(tibble(`1` = 1))\n\ntibble(x = 1:4, y = 1)\n#tibble(x = 1:4, y = 1:2)\n#> Error in `tibble()`:\n#> ! Tibble columns must have compatible sizes.\n#> • Size 4: Existing data.\n#> • Size 2: Column `y`.\n#> ℹ Only values of size one are recycled.\ntibble(\n  x = 1:3,\n  y = x * 2\n)\n```\n\n#### 行名→列\n\n```{r}\ndf3 <- data.frame(\n  age = c(35, 27, 18),\n  hair = c(\"blond\", \"brown\", \"black\"),\n  row.names = c(\"Bob\", \"Susan\", \"Sam\")\n)\ndf3 |> rownames_to_column(var = \"name\")\nas_tibble(df3, rownames = \"name\")\n\n\nis_tibble(df2)\nis_tibble(df3)\nas_tibble(df3)\n```\n\n#### 列表列\n\n```{r}\ndf <- data.frame(x = 1:3)\ndf$y <- list(1:2, 1:3, 1:4)\n\ndata.frame(\n  x = 1:3, \n  y = I(list(1:2, 1:3, 1:4))\n)\n\ntibble(\n  x = 1:3, \n  y = list(1:2, 1:3, 1:4)\n)\n```\n\n### 矩阵和数据框列\n\n行数必须相等\n\n```{r}\ndfm <- data.frame(\n  x = 1:3 * 10\n)\ndfm$y <- matrix(1:9, nrow = 3)\ndfm$z <- data.frame(a = 3:1, b = letters[1:3], stringsAsFactors = FALSE)\ndfm[1, ]\n```\n\n## `NULL`\n\n长度始终为零，并且没有属性。\n\n```{r}\ntypeof(NULL)\nlength(NULL)\nis.null(NULL)\nc()\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"kable","error":true,"eval":true,"cache":true,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":true,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":3,"number-sections":true,"html-math-method":"katex","output-file":"basic_data_type_class.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.553","knitr":{"opts_chunk":{"comment":"#>","collapse":true}},"editor":"visual","theme":"cosmo","callout-appearance":"simple","title":"数据类型和数据结构"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}